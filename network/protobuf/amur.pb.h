// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: amur.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_amur_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_amur_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_amur_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_amur_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[16]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_amur_2eproto;
namespace AMUR {
class AmurControls;
class AmurControlsDefaultTypeInternal;
extern AmurControlsDefaultTypeInternal _AmurControls_default_instance_;
class AmurControls_CameraServos;
class AmurControls_CameraServosDefaultTypeInternal;
extern AmurControls_CameraServosDefaultTypeInternal _AmurControls_CameraServos_default_instance_;
class AmurControls_HandMotors;
class AmurControls_HandMotorsDefaultTypeInternal;
extern AmurControls_HandMotorsDefaultTypeInternal _AmurControls_HandMotors_default_instance_;
class AmurControls_Light;
class AmurControls_LightDefaultTypeInternal;
extern AmurControls_LightDefaultTypeInternal _AmurControls_Light_default_instance_;
class AmurControls_System;
class AmurControls_SystemDefaultTypeInternal;
extern AmurControls_SystemDefaultTypeInternal _AmurControls_System_default_instance_;
class AmurControls_WheelMotors;
class AmurControls_WheelMotorsDefaultTypeInternal;
extern AmurControls_WheelMotorsDefaultTypeInternal _AmurControls_WheelMotors_default_instance_;
class AmurSensors;
class AmurSensorsDefaultTypeInternal;
extern AmurSensorsDefaultTypeInternal _AmurSensors_default_instance_;
class AmurSensors_Accelerometer;
class AmurSensors_AccelerometerDefaultTypeInternal;
extern AmurSensors_AccelerometerDefaultTypeInternal _AmurSensors_Accelerometer_default_instance_;
class AmurSensors_Gyroscope;
class AmurSensors_GyroscopeDefaultTypeInternal;
extern AmurSensors_GyroscopeDefaultTypeInternal _AmurSensors_Gyroscope_default_instance_;
class AmurSensors_HandCurrent;
class AmurSensors_HandCurrentDefaultTypeInternal;
extern AmurSensors_HandCurrentDefaultTypeInternal _AmurSensors_HandCurrent_default_instance_;
class AmurSensors_HandEncoders;
class AmurSensors_HandEncodersDefaultTypeInternal;
extern AmurSensors_HandEncodersDefaultTypeInternal _AmurSensors_HandEncoders_default_instance_;
class AmurSensors_Magnitometer;
class AmurSensors_MagnitometerDefaultTypeInternal;
extern AmurSensors_MagnitometerDefaultTypeInternal _AmurSensors_Magnitometer_default_instance_;
class AmurSensors_Misc;
class AmurSensors_MiscDefaultTypeInternal;
extern AmurSensors_MiscDefaultTypeInternal _AmurSensors_Misc_default_instance_;
class AmurSensors_Temperature;
class AmurSensors_TemperatureDefaultTypeInternal;
extern AmurSensors_TemperatureDefaultTypeInternal _AmurSensors_Temperature_default_instance_;
class AmurSensors_WheelCurrent;
class AmurSensors_WheelCurrentDefaultTypeInternal;
extern AmurSensors_WheelCurrentDefaultTypeInternal _AmurSensors_WheelCurrent_default_instance_;
class AmurSensors_WheelEncoders;
class AmurSensors_WheelEncodersDefaultTypeInternal;
extern AmurSensors_WheelEncodersDefaultTypeInternal _AmurSensors_WheelEncoders_default_instance_;
}  // namespace AMUR
PROTOBUF_NAMESPACE_OPEN
template<> ::AMUR::AmurControls* Arena::CreateMaybeMessage<::AMUR::AmurControls>(Arena*);
template<> ::AMUR::AmurControls_CameraServos* Arena::CreateMaybeMessage<::AMUR::AmurControls_CameraServos>(Arena*);
template<> ::AMUR::AmurControls_HandMotors* Arena::CreateMaybeMessage<::AMUR::AmurControls_HandMotors>(Arena*);
template<> ::AMUR::AmurControls_Light* Arena::CreateMaybeMessage<::AMUR::AmurControls_Light>(Arena*);
template<> ::AMUR::AmurControls_System* Arena::CreateMaybeMessage<::AMUR::AmurControls_System>(Arena*);
template<> ::AMUR::AmurControls_WheelMotors* Arena::CreateMaybeMessage<::AMUR::AmurControls_WheelMotors>(Arena*);
template<> ::AMUR::AmurSensors* Arena::CreateMaybeMessage<::AMUR::AmurSensors>(Arena*);
template<> ::AMUR::AmurSensors_Accelerometer* Arena::CreateMaybeMessage<::AMUR::AmurSensors_Accelerometer>(Arena*);
template<> ::AMUR::AmurSensors_Gyroscope* Arena::CreateMaybeMessage<::AMUR::AmurSensors_Gyroscope>(Arena*);
template<> ::AMUR::AmurSensors_HandCurrent* Arena::CreateMaybeMessage<::AMUR::AmurSensors_HandCurrent>(Arena*);
template<> ::AMUR::AmurSensors_HandEncoders* Arena::CreateMaybeMessage<::AMUR::AmurSensors_HandEncoders>(Arena*);
template<> ::AMUR::AmurSensors_Magnitometer* Arena::CreateMaybeMessage<::AMUR::AmurSensors_Magnitometer>(Arena*);
template<> ::AMUR::AmurSensors_Misc* Arena::CreateMaybeMessage<::AMUR::AmurSensors_Misc>(Arena*);
template<> ::AMUR::AmurSensors_Temperature* Arena::CreateMaybeMessage<::AMUR::AmurSensors_Temperature>(Arena*);
template<> ::AMUR::AmurSensors_WheelCurrent* Arena::CreateMaybeMessage<::AMUR::AmurSensors_WheelCurrent>(Arena*);
template<> ::AMUR::AmurSensors_WheelEncoders* Arena::CreateMaybeMessage<::AMUR::AmurSensors_WheelEncoders>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace AMUR {

// ===================================================================

class AmurControls_CameraServos PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AMUR.AmurControls.CameraServos) */ {
 public:
  inline AmurControls_CameraServos() : AmurControls_CameraServos(nullptr) {};
  virtual ~AmurControls_CameraServos();

  AmurControls_CameraServos(const AmurControls_CameraServos& from);
  AmurControls_CameraServos(AmurControls_CameraServos&& from) noexcept
    : AmurControls_CameraServos() {
    *this = ::std::move(from);
  }

  inline AmurControls_CameraServos& operator=(const AmurControls_CameraServos& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurControls_CameraServos& operator=(AmurControls_CameraServos&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurControls_CameraServos& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurControls_CameraServos* internal_default_instance() {
    return reinterpret_cast<const AmurControls_CameraServos*>(
               &_AmurControls_CameraServos_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AmurControls_CameraServos& a, AmurControls_CameraServos& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurControls_CameraServos* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AmurControls_CameraServos* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurControls_CameraServos* New() const final {
    return CreateMaybeMessage<AmurControls_CameraServos>(nullptr);
  }

  AmurControls_CameraServos* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurControls_CameraServos>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurControls_CameraServos& from);
  void MergeFrom(const AmurControls_CameraServos& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurControls_CameraServos* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AMUR.AmurControls.CameraServos";
  }
  protected:
  explicit AmurControls_CameraServos(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_amur_2eproto);
    return ::descriptor_table_amur_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXAngleFieldNumber = 1,
    kYAngleFieldNumber = 2,
  };
  // int32 xAngle = 1;
  void clear_xangle();
  ::PROTOBUF_NAMESPACE_ID::int32 xangle() const;
  void set_xangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_xangle() const;
  void _internal_set_xangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 yAngle = 2;
  void clear_yangle();
  ::PROTOBUF_NAMESPACE_ID::int32 yangle() const;
  void set_yangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_yangle() const;
  void _internal_set_yangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:AMUR.AmurControls.CameraServos)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 xangle_;
  ::PROTOBUF_NAMESPACE_ID::int32 yangle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_amur_2eproto;
};
// -------------------------------------------------------------------

class AmurControls_WheelMotors PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AMUR.AmurControls.WheelMotors) */ {
 public:
  inline AmurControls_WheelMotors() : AmurControls_WheelMotors(nullptr) {};
  virtual ~AmurControls_WheelMotors();

  AmurControls_WheelMotors(const AmurControls_WheelMotors& from);
  AmurControls_WheelMotors(AmurControls_WheelMotors&& from) noexcept
    : AmurControls_WheelMotors() {
    *this = ::std::move(from);
  }

  inline AmurControls_WheelMotors& operator=(const AmurControls_WheelMotors& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurControls_WheelMotors& operator=(AmurControls_WheelMotors&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurControls_WheelMotors& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurControls_WheelMotors* internal_default_instance() {
    return reinterpret_cast<const AmurControls_WheelMotors*>(
               &_AmurControls_WheelMotors_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AmurControls_WheelMotors& a, AmurControls_WheelMotors& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurControls_WheelMotors* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AmurControls_WheelMotors* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurControls_WheelMotors* New() const final {
    return CreateMaybeMessage<AmurControls_WheelMotors>(nullptr);
  }

  AmurControls_WheelMotors* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurControls_WheelMotors>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurControls_WheelMotors& from);
  void MergeFrom(const AmurControls_WheelMotors& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurControls_WheelMotors* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AMUR.AmurControls.WheelMotors";
  }
  protected:
  explicit AmurControls_WheelMotors(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_amur_2eproto);
    return ::descriptor_table_amur_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftPowerFieldNumber = 1,
    kLeftTimeFieldNumber = 2,
    kRightPowerFieldNumber = 3,
    kRightTimeFieldNumber = 4,
  };
  // int32 leftPower = 1;
  void clear_leftpower();
  ::PROTOBUF_NAMESPACE_ID::int32 leftpower() const;
  void set_leftpower(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_leftpower() const;
  void _internal_set_leftpower(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // uint32 leftTime = 2;
  void clear_lefttime();
  ::PROTOBUF_NAMESPACE_ID::uint32 lefttime() const;
  void set_lefttime(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_lefttime() const;
  void _internal_set_lefttime(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // int32 rightPower = 3;
  void clear_rightpower();
  ::PROTOBUF_NAMESPACE_ID::int32 rightpower() const;
  void set_rightpower(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rightpower() const;
  void _internal_set_rightpower(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // uint32 rightTime = 4;
  void clear_righttime();
  ::PROTOBUF_NAMESPACE_ID::uint32 righttime() const;
  void set_righttime(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_righttime() const;
  void _internal_set_righttime(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:AMUR.AmurControls.WheelMotors)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 leftpower_;
  ::PROTOBUF_NAMESPACE_ID::uint32 lefttime_;
  ::PROTOBUF_NAMESPACE_ID::int32 rightpower_;
  ::PROTOBUF_NAMESPACE_ID::uint32 righttime_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_amur_2eproto;
};
// -------------------------------------------------------------------

class AmurControls_HandMotors PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AMUR.AmurControls.HandMotors) */ {
 public:
  inline AmurControls_HandMotors() : AmurControls_HandMotors(nullptr) {};
  virtual ~AmurControls_HandMotors();

  AmurControls_HandMotors(const AmurControls_HandMotors& from);
  AmurControls_HandMotors(AmurControls_HandMotors&& from) noexcept
    : AmurControls_HandMotors() {
    *this = ::std::move(from);
  }

  inline AmurControls_HandMotors& operator=(const AmurControls_HandMotors& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurControls_HandMotors& operator=(AmurControls_HandMotors&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurControls_HandMotors& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurControls_HandMotors* internal_default_instance() {
    return reinterpret_cast<const AmurControls_HandMotors*>(
               &_AmurControls_HandMotors_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AmurControls_HandMotors& a, AmurControls_HandMotors& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurControls_HandMotors* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AmurControls_HandMotors* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurControls_HandMotors* New() const final {
    return CreateMaybeMessage<AmurControls_HandMotors>(nullptr);
  }

  AmurControls_HandMotors* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurControls_HandMotors>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurControls_HandMotors& from);
  void MergeFrom(const AmurControls_HandMotors& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurControls_HandMotors* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AMUR.AmurControls.HandMotors";
  }
  protected:
  explicit AmurControls_HandMotors(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_amur_2eproto);
    return ::descriptor_table_amur_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftPowerFieldNumber = 1,
    kLeftTimeFieldNumber = 2,
    kRightPowerFieldNumber = 3,
    kRightTimeFieldNumber = 4,
    kLeftRelayFieldNumber = 5,
    kRightRelayFieldNumber = 6,
  };
  // int32 leftPower = 1;
  void clear_leftpower();
  ::PROTOBUF_NAMESPACE_ID::int32 leftpower() const;
  void set_leftpower(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_leftpower() const;
  void _internal_set_leftpower(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // uint32 leftTime = 2;
  void clear_lefttime();
  ::PROTOBUF_NAMESPACE_ID::uint32 lefttime() const;
  void set_lefttime(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_lefttime() const;
  void _internal_set_lefttime(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // int32 rightPower = 3;
  void clear_rightpower();
  ::PROTOBUF_NAMESPACE_ID::int32 rightpower() const;
  void set_rightpower(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rightpower() const;
  void _internal_set_rightpower(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // uint32 rightTime = 4;
  void clear_righttime();
  ::PROTOBUF_NAMESPACE_ID::uint32 righttime() const;
  void set_righttime(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_righttime() const;
  void _internal_set_righttime(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool leftRelay = 5;
  void clear_leftrelay();
  bool leftrelay() const;
  void set_leftrelay(bool value);
  private:
  bool _internal_leftrelay() const;
  void _internal_set_leftrelay(bool value);
  public:

  // bool rightRelay = 6;
  void clear_rightrelay();
  bool rightrelay() const;
  void set_rightrelay(bool value);
  private:
  bool _internal_rightrelay() const;
  void _internal_set_rightrelay(bool value);
  public:

  // @@protoc_insertion_point(class_scope:AMUR.AmurControls.HandMotors)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 leftpower_;
  ::PROTOBUF_NAMESPACE_ID::uint32 lefttime_;
  ::PROTOBUF_NAMESPACE_ID::int32 rightpower_;
  ::PROTOBUF_NAMESPACE_ID::uint32 righttime_;
  bool leftrelay_;
  bool rightrelay_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_amur_2eproto;
};
// -------------------------------------------------------------------

class AmurControls_Light PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AMUR.AmurControls.Light) */ {
 public:
  inline AmurControls_Light() : AmurControls_Light(nullptr) {};
  virtual ~AmurControls_Light();

  AmurControls_Light(const AmurControls_Light& from);
  AmurControls_Light(AmurControls_Light&& from) noexcept
    : AmurControls_Light() {
    *this = ::std::move(from);
  }

  inline AmurControls_Light& operator=(const AmurControls_Light& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurControls_Light& operator=(AmurControls_Light&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurControls_Light& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurControls_Light* internal_default_instance() {
    return reinterpret_cast<const AmurControls_Light*>(
               &_AmurControls_Light_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AmurControls_Light& a, AmurControls_Light& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurControls_Light* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AmurControls_Light* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurControls_Light* New() const final {
    return CreateMaybeMessage<AmurControls_Light>(nullptr);
  }

  AmurControls_Light* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurControls_Light>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurControls_Light& from);
  void MergeFrom(const AmurControls_Light& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurControls_Light* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AMUR.AmurControls.Light";
  }
  protected:
  explicit AmurControls_Light(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_amur_2eproto);
    return ::descriptor_table_amur_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLedLeftPowerFieldNumber = 1,
    kLedRightPowerFieldNumber = 2,
  };
  // uint32 ledLeftPower = 1;
  void clear_ledleftpower();
  ::PROTOBUF_NAMESPACE_ID::uint32 ledleftpower() const;
  void set_ledleftpower(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_ledleftpower() const;
  void _internal_set_ledleftpower(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 ledRightPower = 2;
  void clear_ledrightpower();
  ::PROTOBUF_NAMESPACE_ID::uint32 ledrightpower() const;
  void set_ledrightpower(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_ledrightpower() const;
  void _internal_set_ledrightpower(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:AMUR.AmurControls.Light)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ledleftpower_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ledrightpower_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_amur_2eproto;
};
// -------------------------------------------------------------------

class AmurControls_System PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AMUR.AmurControls.System) */ {
 public:
  inline AmurControls_System() : AmurControls_System(nullptr) {};
  virtual ~AmurControls_System();

  AmurControls_System(const AmurControls_System& from);
  AmurControls_System(AmurControls_System&& from) noexcept
    : AmurControls_System() {
    *this = ::std::move(from);
  }

  inline AmurControls_System& operator=(const AmurControls_System& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurControls_System& operator=(AmurControls_System&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurControls_System& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurControls_System* internal_default_instance() {
    return reinterpret_cast<const AmurControls_System*>(
               &_AmurControls_System_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AmurControls_System& a, AmurControls_System& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurControls_System* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AmurControls_System* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurControls_System* New() const final {
    return CreateMaybeMessage<AmurControls_System>(nullptr);
  }

  AmurControls_System* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurControls_System>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurControls_System& from);
  void MergeFrom(const AmurControls_System& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurControls_System* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AMUR.AmurControls.System";
  }
  protected:
  explicit AmurControls_System(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_amur_2eproto);
    return ::descriptor_table_amur_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeOnAmurFieldNumber = 3,
    kHaltFlagFieldNumber = 1,
    kRestartFlagFieldNumber = 2,
  };
  // string timeOnAmur = 3;
  void clear_timeonamur();
  const std::string& timeonamur() const;
  void set_timeonamur(const std::string& value);
  void set_timeonamur(std::string&& value);
  void set_timeonamur(const char* value);
  void set_timeonamur(const char* value, size_t size);
  std::string* mutable_timeonamur();
  std::string* release_timeonamur();
  void set_allocated_timeonamur(std::string* timeonamur);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_timeonamur();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_timeonamur(
      std::string* timeonamur);
  private:
  const std::string& _internal_timeonamur() const;
  void _internal_set_timeonamur(const std::string& value);
  std::string* _internal_mutable_timeonamur();
  public:

  // bool haltFlag = 1;
  void clear_haltflag();
  bool haltflag() const;
  void set_haltflag(bool value);
  private:
  bool _internal_haltflag() const;
  void _internal_set_haltflag(bool value);
  public:

  // bool restartFlag = 2;
  void clear_restartflag();
  bool restartflag() const;
  void set_restartflag(bool value);
  private:
  bool _internal_restartflag() const;
  void _internal_set_restartflag(bool value);
  public:

  // @@protoc_insertion_point(class_scope:AMUR.AmurControls.System)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timeonamur_;
  bool haltflag_;
  bool restartflag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_amur_2eproto;
};
// -------------------------------------------------------------------

class AmurControls PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AMUR.AmurControls) */ {
 public:
  inline AmurControls() : AmurControls(nullptr) {};
  virtual ~AmurControls();

  AmurControls(const AmurControls& from);
  AmurControls(AmurControls&& from) noexcept
    : AmurControls() {
    *this = ::std::move(from);
  }

  inline AmurControls& operator=(const AmurControls& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurControls& operator=(AmurControls&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurControls& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurControls* internal_default_instance() {
    return reinterpret_cast<const AmurControls*>(
               &_AmurControls_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AmurControls& a, AmurControls& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurControls* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AmurControls* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurControls* New() const final {
    return CreateMaybeMessage<AmurControls>(nullptr);
  }

  AmurControls* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurControls>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurControls& from);
  void MergeFrom(const AmurControls& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurControls* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AMUR.AmurControls";
  }
  protected:
  explicit AmurControls(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_amur_2eproto);
    return ::descriptor_table_amur_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef AmurControls_CameraServos CameraServos;
  typedef AmurControls_WheelMotors WheelMotors;
  typedef AmurControls_HandMotors HandMotors;
  typedef AmurControls_Light Light;
  typedef AmurControls_System System;

  // accessors -------------------------------------------------------

  enum : int {
    kCameraServosFieldNumber = 1,
    kWheelMotorsFieldNumber = 2,
    kHandMotorsFieldNumber = 3,
    kLightFieldNumber = 4,
    kSystemFieldNumber = 5,
  };
  // .AMUR.AmurControls.CameraServos cameraServos = 1;
  bool has_cameraservos() const;
  private:
  bool _internal_has_cameraservos() const;
  public:
  void clear_cameraservos();
  const ::AMUR::AmurControls_CameraServos& cameraservos() const;
  ::AMUR::AmurControls_CameraServos* release_cameraservos();
  ::AMUR::AmurControls_CameraServos* mutable_cameraservos();
  void set_allocated_cameraservos(::AMUR::AmurControls_CameraServos* cameraservos);
  private:
  const ::AMUR::AmurControls_CameraServos& _internal_cameraservos() const;
  ::AMUR::AmurControls_CameraServos* _internal_mutable_cameraservos();
  public:
  void unsafe_arena_set_allocated_cameraservos(
      ::AMUR::AmurControls_CameraServos* cameraservos);
  ::AMUR::AmurControls_CameraServos* unsafe_arena_release_cameraservos();

  // .AMUR.AmurControls.WheelMotors wheelMotors = 2;
  bool has_wheelmotors() const;
  private:
  bool _internal_has_wheelmotors() const;
  public:
  void clear_wheelmotors();
  const ::AMUR::AmurControls_WheelMotors& wheelmotors() const;
  ::AMUR::AmurControls_WheelMotors* release_wheelmotors();
  ::AMUR::AmurControls_WheelMotors* mutable_wheelmotors();
  void set_allocated_wheelmotors(::AMUR::AmurControls_WheelMotors* wheelmotors);
  private:
  const ::AMUR::AmurControls_WheelMotors& _internal_wheelmotors() const;
  ::AMUR::AmurControls_WheelMotors* _internal_mutable_wheelmotors();
  public:
  void unsafe_arena_set_allocated_wheelmotors(
      ::AMUR::AmurControls_WheelMotors* wheelmotors);
  ::AMUR::AmurControls_WheelMotors* unsafe_arena_release_wheelmotors();

  // .AMUR.AmurControls.HandMotors handMotors = 3;
  bool has_handmotors() const;
  private:
  bool _internal_has_handmotors() const;
  public:
  void clear_handmotors();
  const ::AMUR::AmurControls_HandMotors& handmotors() const;
  ::AMUR::AmurControls_HandMotors* release_handmotors();
  ::AMUR::AmurControls_HandMotors* mutable_handmotors();
  void set_allocated_handmotors(::AMUR::AmurControls_HandMotors* handmotors);
  private:
  const ::AMUR::AmurControls_HandMotors& _internal_handmotors() const;
  ::AMUR::AmurControls_HandMotors* _internal_mutable_handmotors();
  public:
  void unsafe_arena_set_allocated_handmotors(
      ::AMUR::AmurControls_HandMotors* handmotors);
  ::AMUR::AmurControls_HandMotors* unsafe_arena_release_handmotors();

  // .AMUR.AmurControls.Light light = 4;
  bool has_light() const;
  private:
  bool _internal_has_light() const;
  public:
  void clear_light();
  const ::AMUR::AmurControls_Light& light() const;
  ::AMUR::AmurControls_Light* release_light();
  ::AMUR::AmurControls_Light* mutable_light();
  void set_allocated_light(::AMUR::AmurControls_Light* light);
  private:
  const ::AMUR::AmurControls_Light& _internal_light() const;
  ::AMUR::AmurControls_Light* _internal_mutable_light();
  public:
  void unsafe_arena_set_allocated_light(
      ::AMUR::AmurControls_Light* light);
  ::AMUR::AmurControls_Light* unsafe_arena_release_light();

  // .AMUR.AmurControls.System system = 5;
  bool has_system() const;
  private:
  bool _internal_has_system() const;
  public:
  void clear_system();
  const ::AMUR::AmurControls_System& system() const;
  ::AMUR::AmurControls_System* release_system();
  ::AMUR::AmurControls_System* mutable_system();
  void set_allocated_system(::AMUR::AmurControls_System* system);
  private:
  const ::AMUR::AmurControls_System& _internal_system() const;
  ::AMUR::AmurControls_System* _internal_mutable_system();
  public:
  void unsafe_arena_set_allocated_system(
      ::AMUR::AmurControls_System* system);
  ::AMUR::AmurControls_System* unsafe_arena_release_system();

  // @@protoc_insertion_point(class_scope:AMUR.AmurControls)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::AMUR::AmurControls_CameraServos* cameraservos_;
  ::AMUR::AmurControls_WheelMotors* wheelmotors_;
  ::AMUR::AmurControls_HandMotors* handmotors_;
  ::AMUR::AmurControls_Light* light_;
  ::AMUR::AmurControls_System* system_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_amur_2eproto;
};
// -------------------------------------------------------------------

class AmurSensors_Accelerometer PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AMUR.AmurSensors.Accelerometer) */ {
 public:
  inline AmurSensors_Accelerometer() : AmurSensors_Accelerometer(nullptr) {};
  virtual ~AmurSensors_Accelerometer();

  AmurSensors_Accelerometer(const AmurSensors_Accelerometer& from);
  AmurSensors_Accelerometer(AmurSensors_Accelerometer&& from) noexcept
    : AmurSensors_Accelerometer() {
    *this = ::std::move(from);
  }

  inline AmurSensors_Accelerometer& operator=(const AmurSensors_Accelerometer& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurSensors_Accelerometer& operator=(AmurSensors_Accelerometer&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurSensors_Accelerometer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurSensors_Accelerometer* internal_default_instance() {
    return reinterpret_cast<const AmurSensors_Accelerometer*>(
               &_AmurSensors_Accelerometer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AmurSensors_Accelerometer& a, AmurSensors_Accelerometer& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurSensors_Accelerometer* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AmurSensors_Accelerometer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurSensors_Accelerometer* New() const final {
    return CreateMaybeMessage<AmurSensors_Accelerometer>(nullptr);
  }

  AmurSensors_Accelerometer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurSensors_Accelerometer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurSensors_Accelerometer& from);
  void MergeFrom(const AmurSensors_Accelerometer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurSensors_Accelerometer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AMUR.AmurSensors.Accelerometer";
  }
  protected:
  explicit AmurSensors_Accelerometer(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_amur_2eproto);
    return ::descriptor_table_amur_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:AMUR.AmurSensors.Accelerometer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  float z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_amur_2eproto;
};
// -------------------------------------------------------------------

class AmurSensors_Gyroscope PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AMUR.AmurSensors.Gyroscope) */ {
 public:
  inline AmurSensors_Gyroscope() : AmurSensors_Gyroscope(nullptr) {};
  virtual ~AmurSensors_Gyroscope();

  AmurSensors_Gyroscope(const AmurSensors_Gyroscope& from);
  AmurSensors_Gyroscope(AmurSensors_Gyroscope&& from) noexcept
    : AmurSensors_Gyroscope() {
    *this = ::std::move(from);
  }

  inline AmurSensors_Gyroscope& operator=(const AmurSensors_Gyroscope& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurSensors_Gyroscope& operator=(AmurSensors_Gyroscope&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurSensors_Gyroscope& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurSensors_Gyroscope* internal_default_instance() {
    return reinterpret_cast<const AmurSensors_Gyroscope*>(
               &_AmurSensors_Gyroscope_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AmurSensors_Gyroscope& a, AmurSensors_Gyroscope& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurSensors_Gyroscope* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AmurSensors_Gyroscope* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurSensors_Gyroscope* New() const final {
    return CreateMaybeMessage<AmurSensors_Gyroscope>(nullptr);
  }

  AmurSensors_Gyroscope* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurSensors_Gyroscope>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurSensors_Gyroscope& from);
  void MergeFrom(const AmurSensors_Gyroscope& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurSensors_Gyroscope* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AMUR.AmurSensors.Gyroscope";
  }
  protected:
  explicit AmurSensors_Gyroscope(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_amur_2eproto);
    return ::descriptor_table_amur_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:AMUR.AmurSensors.Gyroscope)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  float z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_amur_2eproto;
};
// -------------------------------------------------------------------

class AmurSensors_Magnitometer PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AMUR.AmurSensors.Magnitometer) */ {
 public:
  inline AmurSensors_Magnitometer() : AmurSensors_Magnitometer(nullptr) {};
  virtual ~AmurSensors_Magnitometer();

  AmurSensors_Magnitometer(const AmurSensors_Magnitometer& from);
  AmurSensors_Magnitometer(AmurSensors_Magnitometer&& from) noexcept
    : AmurSensors_Magnitometer() {
    *this = ::std::move(from);
  }

  inline AmurSensors_Magnitometer& operator=(const AmurSensors_Magnitometer& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurSensors_Magnitometer& operator=(AmurSensors_Magnitometer&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurSensors_Magnitometer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurSensors_Magnitometer* internal_default_instance() {
    return reinterpret_cast<const AmurSensors_Magnitometer*>(
               &_AmurSensors_Magnitometer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AmurSensors_Magnitometer& a, AmurSensors_Magnitometer& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurSensors_Magnitometer* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AmurSensors_Magnitometer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurSensors_Magnitometer* New() const final {
    return CreateMaybeMessage<AmurSensors_Magnitometer>(nullptr);
  }

  AmurSensors_Magnitometer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurSensors_Magnitometer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurSensors_Magnitometer& from);
  void MergeFrom(const AmurSensors_Magnitometer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurSensors_Magnitometer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AMUR.AmurSensors.Magnitometer";
  }
  protected:
  explicit AmurSensors_Magnitometer(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_amur_2eproto);
    return ::descriptor_table_amur_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:AMUR.AmurSensors.Magnitometer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  float z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_amur_2eproto;
};
// -------------------------------------------------------------------

class AmurSensors_WheelEncoders PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AMUR.AmurSensors.WheelEncoders) */ {
 public:
  inline AmurSensors_WheelEncoders() : AmurSensors_WheelEncoders(nullptr) {};
  virtual ~AmurSensors_WheelEncoders();

  AmurSensors_WheelEncoders(const AmurSensors_WheelEncoders& from);
  AmurSensors_WheelEncoders(AmurSensors_WheelEncoders&& from) noexcept
    : AmurSensors_WheelEncoders() {
    *this = ::std::move(from);
  }

  inline AmurSensors_WheelEncoders& operator=(const AmurSensors_WheelEncoders& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurSensors_WheelEncoders& operator=(AmurSensors_WheelEncoders&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurSensors_WheelEncoders& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurSensors_WheelEncoders* internal_default_instance() {
    return reinterpret_cast<const AmurSensors_WheelEncoders*>(
               &_AmurSensors_WheelEncoders_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AmurSensors_WheelEncoders& a, AmurSensors_WheelEncoders& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurSensors_WheelEncoders* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AmurSensors_WheelEncoders* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurSensors_WheelEncoders* New() const final {
    return CreateMaybeMessage<AmurSensors_WheelEncoders>(nullptr);
  }

  AmurSensors_WheelEncoders* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurSensors_WheelEncoders>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurSensors_WheelEncoders& from);
  void MergeFrom(const AmurSensors_WheelEncoders& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurSensors_WheelEncoders* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AMUR.AmurSensors.WheelEncoders";
  }
  protected:
  explicit AmurSensors_WheelEncoders(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_amur_2eproto);
    return ::descriptor_table_amur_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftAngleFieldNumber = 1,
    kRightAngleFieldNumber = 2,
  };
  // int32 leftAngle = 1;
  void clear_leftangle();
  ::PROTOBUF_NAMESPACE_ID::int32 leftangle() const;
  void set_leftangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_leftangle() const;
  void _internal_set_leftangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 rightAngle = 2;
  void clear_rightangle();
  ::PROTOBUF_NAMESPACE_ID::int32 rightangle() const;
  void set_rightangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rightangle() const;
  void _internal_set_rightangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:AMUR.AmurSensors.WheelEncoders)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 leftangle_;
  ::PROTOBUF_NAMESPACE_ID::int32 rightangle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_amur_2eproto;
};
// -------------------------------------------------------------------

class AmurSensors_HandEncoders PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AMUR.AmurSensors.HandEncoders) */ {
 public:
  inline AmurSensors_HandEncoders() : AmurSensors_HandEncoders(nullptr) {};
  virtual ~AmurSensors_HandEncoders();

  AmurSensors_HandEncoders(const AmurSensors_HandEncoders& from);
  AmurSensors_HandEncoders(AmurSensors_HandEncoders&& from) noexcept
    : AmurSensors_HandEncoders() {
    *this = ::std::move(from);
  }

  inline AmurSensors_HandEncoders& operator=(const AmurSensors_HandEncoders& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurSensors_HandEncoders& operator=(AmurSensors_HandEncoders&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurSensors_HandEncoders& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurSensors_HandEncoders* internal_default_instance() {
    return reinterpret_cast<const AmurSensors_HandEncoders*>(
               &_AmurSensors_HandEncoders_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AmurSensors_HandEncoders& a, AmurSensors_HandEncoders& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurSensors_HandEncoders* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AmurSensors_HandEncoders* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurSensors_HandEncoders* New() const final {
    return CreateMaybeMessage<AmurSensors_HandEncoders>(nullptr);
  }

  AmurSensors_HandEncoders* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurSensors_HandEncoders>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurSensors_HandEncoders& from);
  void MergeFrom(const AmurSensors_HandEncoders& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurSensors_HandEncoders* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AMUR.AmurSensors.HandEncoders";
  }
  protected:
  explicit AmurSensors_HandEncoders(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_amur_2eproto);
    return ::descriptor_table_amur_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftInternalAngleFieldNumber = 1,
    kRightInternalAngleFieldNumber = 2,
    kLeftOuterAngleFieldNumber = 3,
    kRightOuterAngleFieldNumber = 4,
  };
  // int32 leftInternalAngle = 1;
  void clear_leftinternalangle();
  ::PROTOBUF_NAMESPACE_ID::int32 leftinternalangle() const;
  void set_leftinternalangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_leftinternalangle() const;
  void _internal_set_leftinternalangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 rightInternalAngle = 2;
  void clear_rightinternalangle();
  ::PROTOBUF_NAMESPACE_ID::int32 rightinternalangle() const;
  void set_rightinternalangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rightinternalangle() const;
  void _internal_set_rightinternalangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 leftOuterAngle = 3;
  void clear_leftouterangle();
  ::PROTOBUF_NAMESPACE_ID::int32 leftouterangle() const;
  void set_leftouterangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_leftouterangle() const;
  void _internal_set_leftouterangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 rightOuterAngle = 4;
  void clear_rightouterangle();
  ::PROTOBUF_NAMESPACE_ID::int32 rightouterangle() const;
  void set_rightouterangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rightouterangle() const;
  void _internal_set_rightouterangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:AMUR.AmurSensors.HandEncoders)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 leftinternalangle_;
  ::PROTOBUF_NAMESPACE_ID::int32 rightinternalangle_;
  ::PROTOBUF_NAMESPACE_ID::int32 leftouterangle_;
  ::PROTOBUF_NAMESPACE_ID::int32 rightouterangle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_amur_2eproto;
};
// -------------------------------------------------------------------

class AmurSensors_Temperature PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AMUR.AmurSensors.Temperature) */ {
 public:
  inline AmurSensors_Temperature() : AmurSensors_Temperature(nullptr) {};
  virtual ~AmurSensors_Temperature();

  AmurSensors_Temperature(const AmurSensors_Temperature& from);
  AmurSensors_Temperature(AmurSensors_Temperature&& from) noexcept
    : AmurSensors_Temperature() {
    *this = ::std::move(from);
  }

  inline AmurSensors_Temperature& operator=(const AmurSensors_Temperature& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurSensors_Temperature& operator=(AmurSensors_Temperature&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurSensors_Temperature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurSensors_Temperature* internal_default_instance() {
    return reinterpret_cast<const AmurSensors_Temperature*>(
               &_AmurSensors_Temperature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AmurSensors_Temperature& a, AmurSensors_Temperature& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurSensors_Temperature* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AmurSensors_Temperature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurSensors_Temperature* New() const final {
    return CreateMaybeMessage<AmurSensors_Temperature>(nullptr);
  }

  AmurSensors_Temperature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurSensors_Temperature>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurSensors_Temperature& from);
  void MergeFrom(const AmurSensors_Temperature& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurSensors_Temperature* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AMUR.AmurSensors.Temperature";
  }
  protected:
  explicit AmurSensors_Temperature(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_amur_2eproto);
    return ::descriptor_table_amur_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTempAccelerometerFieldNumber = 1,
    kTempCPUFieldNumber = 2,
    kTempPressureFieldNumber = 3,
  };
  // int32 tempAccelerometer = 1;
  void clear_tempaccelerometer();
  ::PROTOBUF_NAMESPACE_ID::int32 tempaccelerometer() const;
  void set_tempaccelerometer(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_tempaccelerometer() const;
  void _internal_set_tempaccelerometer(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 tempCPU = 2;
  void clear_tempcpu();
  ::PROTOBUF_NAMESPACE_ID::int32 tempcpu() const;
  void set_tempcpu(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_tempcpu() const;
  void _internal_set_tempcpu(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 tempPressure = 3;
  void clear_temppressure();
  ::PROTOBUF_NAMESPACE_ID::int32 temppressure() const;
  void set_temppressure(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_temppressure() const;
  void _internal_set_temppressure(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:AMUR.AmurSensors.Temperature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 tempaccelerometer_;
  ::PROTOBUF_NAMESPACE_ID::int32 tempcpu_;
  ::PROTOBUF_NAMESPACE_ID::int32 temppressure_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_amur_2eproto;
};
// -------------------------------------------------------------------

class AmurSensors_WheelCurrent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AMUR.AmurSensors.WheelCurrent) */ {
 public:
  inline AmurSensors_WheelCurrent() : AmurSensors_WheelCurrent(nullptr) {};
  virtual ~AmurSensors_WheelCurrent();

  AmurSensors_WheelCurrent(const AmurSensors_WheelCurrent& from);
  AmurSensors_WheelCurrent(AmurSensors_WheelCurrent&& from) noexcept
    : AmurSensors_WheelCurrent() {
    *this = ::std::move(from);
  }

  inline AmurSensors_WheelCurrent& operator=(const AmurSensors_WheelCurrent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurSensors_WheelCurrent& operator=(AmurSensors_WheelCurrent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurSensors_WheelCurrent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurSensors_WheelCurrent* internal_default_instance() {
    return reinterpret_cast<const AmurSensors_WheelCurrent*>(
               &_AmurSensors_WheelCurrent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AmurSensors_WheelCurrent& a, AmurSensors_WheelCurrent& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurSensors_WheelCurrent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AmurSensors_WheelCurrent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurSensors_WheelCurrent* New() const final {
    return CreateMaybeMessage<AmurSensors_WheelCurrent>(nullptr);
  }

  AmurSensors_WheelCurrent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurSensors_WheelCurrent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurSensors_WheelCurrent& from);
  void MergeFrom(const AmurSensors_WheelCurrent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurSensors_WheelCurrent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AMUR.AmurSensors.WheelCurrent";
  }
  protected:
  explicit AmurSensors_WheelCurrent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_amur_2eproto);
    return ::descriptor_table_amur_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftCurrentFieldNumber = 1,
    kRightCurrentFieldNumber = 2,
  };
  // uint32 leftCurrent = 1;
  void clear_leftcurrent();
  ::PROTOBUF_NAMESPACE_ID::uint32 leftcurrent() const;
  void set_leftcurrent(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_leftcurrent() const;
  void _internal_set_leftcurrent(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 rightCurrent = 2;
  void clear_rightcurrent();
  ::PROTOBUF_NAMESPACE_ID::uint32 rightcurrent() const;
  void set_rightcurrent(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_rightcurrent() const;
  void _internal_set_rightcurrent(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:AMUR.AmurSensors.WheelCurrent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 leftcurrent_;
  ::PROTOBUF_NAMESPACE_ID::uint32 rightcurrent_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_amur_2eproto;
};
// -------------------------------------------------------------------

class AmurSensors_HandCurrent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AMUR.AmurSensors.HandCurrent) */ {
 public:
  inline AmurSensors_HandCurrent() : AmurSensors_HandCurrent(nullptr) {};
  virtual ~AmurSensors_HandCurrent();

  AmurSensors_HandCurrent(const AmurSensors_HandCurrent& from);
  AmurSensors_HandCurrent(AmurSensors_HandCurrent&& from) noexcept
    : AmurSensors_HandCurrent() {
    *this = ::std::move(from);
  }

  inline AmurSensors_HandCurrent& operator=(const AmurSensors_HandCurrent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurSensors_HandCurrent& operator=(AmurSensors_HandCurrent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurSensors_HandCurrent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurSensors_HandCurrent* internal_default_instance() {
    return reinterpret_cast<const AmurSensors_HandCurrent*>(
               &_AmurSensors_HandCurrent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AmurSensors_HandCurrent& a, AmurSensors_HandCurrent& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurSensors_HandCurrent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AmurSensors_HandCurrent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurSensors_HandCurrent* New() const final {
    return CreateMaybeMessage<AmurSensors_HandCurrent>(nullptr);
  }

  AmurSensors_HandCurrent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurSensors_HandCurrent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurSensors_HandCurrent& from);
  void MergeFrom(const AmurSensors_HandCurrent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurSensors_HandCurrent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AMUR.AmurSensors.HandCurrent";
  }
  protected:
  explicit AmurSensors_HandCurrent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_amur_2eproto);
    return ::descriptor_table_amur_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftCurrentFieldNumber = 1,
    kRightCurrentFieldNumber = 2,
  };
  // uint32 leftCurrent = 1;
  void clear_leftcurrent();
  ::PROTOBUF_NAMESPACE_ID::uint32 leftcurrent() const;
  void set_leftcurrent(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_leftcurrent() const;
  void _internal_set_leftcurrent(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 rightCurrent = 2;
  void clear_rightcurrent();
  ::PROTOBUF_NAMESPACE_ID::uint32 rightcurrent() const;
  void set_rightcurrent(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_rightcurrent() const;
  void _internal_set_rightcurrent(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:AMUR.AmurSensors.HandCurrent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 leftcurrent_;
  ::PROTOBUF_NAMESPACE_ID::uint32 rightcurrent_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_amur_2eproto;
};
// -------------------------------------------------------------------

class AmurSensors_Misc PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AMUR.AmurSensors.Misc) */ {
 public:
  inline AmurSensors_Misc() : AmurSensors_Misc(nullptr) {};
  virtual ~AmurSensors_Misc();

  AmurSensors_Misc(const AmurSensors_Misc& from);
  AmurSensors_Misc(AmurSensors_Misc&& from) noexcept
    : AmurSensors_Misc() {
    *this = ::std::move(from);
  }

  inline AmurSensors_Misc& operator=(const AmurSensors_Misc& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurSensors_Misc& operator=(AmurSensors_Misc&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurSensors_Misc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurSensors_Misc* internal_default_instance() {
    return reinterpret_cast<const AmurSensors_Misc*>(
               &_AmurSensors_Misc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AmurSensors_Misc& a, AmurSensors_Misc& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurSensors_Misc* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AmurSensors_Misc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurSensors_Misc* New() const final {
    return CreateMaybeMessage<AmurSensors_Misc>(nullptr);
  }

  AmurSensors_Misc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurSensors_Misc>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurSensors_Misc& from);
  void MergeFrom(const AmurSensors_Misc& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurSensors_Misc* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AMUR.AmurSensors.Misc";
  }
  protected:
  explicit AmurSensors_Misc(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_amur_2eproto);
    return ::descriptor_table_amur_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGasFieldNumber = 1,
    kBatteryVoltageFieldNumber = 2,
    kRaspberryVoltageFieldNumber = 3,
    kPressureFieldNumber = 4,
  };
  // int32 gas = 1;
  void clear_gas();
  ::PROTOBUF_NAMESPACE_ID::int32 gas() const;
  void set_gas(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_gas() const;
  void _internal_set_gas(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 batteryVoltage = 2;
  void clear_batteryvoltage();
  ::PROTOBUF_NAMESPACE_ID::int32 batteryvoltage() const;
  void set_batteryvoltage(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_batteryvoltage() const;
  void _internal_set_batteryvoltage(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 raspberryVoltage = 3;
  void clear_raspberryvoltage();
  ::PROTOBUF_NAMESPACE_ID::int32 raspberryvoltage() const;
  void set_raspberryvoltage(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_raspberryvoltage() const;
  void _internal_set_raspberryvoltage(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // float pressure = 4;
  void clear_pressure();
  float pressure() const;
  void set_pressure(float value);
  private:
  float _internal_pressure() const;
  void _internal_set_pressure(float value);
  public:

  // @@protoc_insertion_point(class_scope:AMUR.AmurSensors.Misc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 gas_;
  ::PROTOBUF_NAMESPACE_ID::int32 batteryvoltage_;
  ::PROTOBUF_NAMESPACE_ID::int32 raspberryvoltage_;
  float pressure_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_amur_2eproto;
};
// -------------------------------------------------------------------

class AmurSensors PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AMUR.AmurSensors) */ {
 public:
  inline AmurSensors() : AmurSensors(nullptr) {};
  virtual ~AmurSensors();

  AmurSensors(const AmurSensors& from);
  AmurSensors(AmurSensors&& from) noexcept
    : AmurSensors() {
    *this = ::std::move(from);
  }

  inline AmurSensors& operator=(const AmurSensors& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurSensors& operator=(AmurSensors&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurSensors& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurSensors* internal_default_instance() {
    return reinterpret_cast<const AmurSensors*>(
               &_AmurSensors_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(AmurSensors& a, AmurSensors& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurSensors* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AmurSensors* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurSensors* New() const final {
    return CreateMaybeMessage<AmurSensors>(nullptr);
  }

  AmurSensors* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurSensors>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurSensors& from);
  void MergeFrom(const AmurSensors& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurSensors* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AMUR.AmurSensors";
  }
  protected:
  explicit AmurSensors(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_amur_2eproto);
    return ::descriptor_table_amur_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef AmurSensors_Accelerometer Accelerometer;
  typedef AmurSensors_Gyroscope Gyroscope;
  typedef AmurSensors_Magnitometer Magnitometer;
  typedef AmurSensors_WheelEncoders WheelEncoders;
  typedef AmurSensors_HandEncoders HandEncoders;
  typedef AmurSensors_Temperature Temperature;
  typedef AmurSensors_WheelCurrent WheelCurrent;
  typedef AmurSensors_HandCurrent HandCurrent;
  typedef AmurSensors_Misc Misc;

  // accessors -------------------------------------------------------

  enum : int {
    kAccelerometerFieldNumber = 1,
    kGyroscopeFieldNumber = 2,
    kMagnitometerFieldNumber = 3,
    kWheelEncodersFieldNumber = 4,
    kHandEncodersFieldNumber = 5,
    kTemperatureFieldNumber = 6,
    kMiscFieldNumber = 7,
  };
  // .AMUR.AmurSensors.Accelerometer accelerometer = 1;
  bool has_accelerometer() const;
  private:
  bool _internal_has_accelerometer() const;
  public:
  void clear_accelerometer();
  const ::AMUR::AmurSensors_Accelerometer& accelerometer() const;
  ::AMUR::AmurSensors_Accelerometer* release_accelerometer();
  ::AMUR::AmurSensors_Accelerometer* mutable_accelerometer();
  void set_allocated_accelerometer(::AMUR::AmurSensors_Accelerometer* accelerometer);
  private:
  const ::AMUR::AmurSensors_Accelerometer& _internal_accelerometer() const;
  ::AMUR::AmurSensors_Accelerometer* _internal_mutable_accelerometer();
  public:
  void unsafe_arena_set_allocated_accelerometer(
      ::AMUR::AmurSensors_Accelerometer* accelerometer);
  ::AMUR::AmurSensors_Accelerometer* unsafe_arena_release_accelerometer();

  // .AMUR.AmurSensors.Gyroscope gyroscope = 2;
  bool has_gyroscope() const;
  private:
  bool _internal_has_gyroscope() const;
  public:
  void clear_gyroscope();
  const ::AMUR::AmurSensors_Gyroscope& gyroscope() const;
  ::AMUR::AmurSensors_Gyroscope* release_gyroscope();
  ::AMUR::AmurSensors_Gyroscope* mutable_gyroscope();
  void set_allocated_gyroscope(::AMUR::AmurSensors_Gyroscope* gyroscope);
  private:
  const ::AMUR::AmurSensors_Gyroscope& _internal_gyroscope() const;
  ::AMUR::AmurSensors_Gyroscope* _internal_mutable_gyroscope();
  public:
  void unsafe_arena_set_allocated_gyroscope(
      ::AMUR::AmurSensors_Gyroscope* gyroscope);
  ::AMUR::AmurSensors_Gyroscope* unsafe_arena_release_gyroscope();

  // .AMUR.AmurSensors.Magnitometer magnitometer = 3;
  bool has_magnitometer() const;
  private:
  bool _internal_has_magnitometer() const;
  public:
  void clear_magnitometer();
  const ::AMUR::AmurSensors_Magnitometer& magnitometer() const;
  ::AMUR::AmurSensors_Magnitometer* release_magnitometer();
  ::AMUR::AmurSensors_Magnitometer* mutable_magnitometer();
  void set_allocated_magnitometer(::AMUR::AmurSensors_Magnitometer* magnitometer);
  private:
  const ::AMUR::AmurSensors_Magnitometer& _internal_magnitometer() const;
  ::AMUR::AmurSensors_Magnitometer* _internal_mutable_magnitometer();
  public:
  void unsafe_arena_set_allocated_magnitometer(
      ::AMUR::AmurSensors_Magnitometer* magnitometer);
  ::AMUR::AmurSensors_Magnitometer* unsafe_arena_release_magnitometer();

  // .AMUR.AmurSensors.WheelEncoders wheelEncoders = 4;
  bool has_wheelencoders() const;
  private:
  bool _internal_has_wheelencoders() const;
  public:
  void clear_wheelencoders();
  const ::AMUR::AmurSensors_WheelEncoders& wheelencoders() const;
  ::AMUR::AmurSensors_WheelEncoders* release_wheelencoders();
  ::AMUR::AmurSensors_WheelEncoders* mutable_wheelencoders();
  void set_allocated_wheelencoders(::AMUR::AmurSensors_WheelEncoders* wheelencoders);
  private:
  const ::AMUR::AmurSensors_WheelEncoders& _internal_wheelencoders() const;
  ::AMUR::AmurSensors_WheelEncoders* _internal_mutable_wheelencoders();
  public:
  void unsafe_arena_set_allocated_wheelencoders(
      ::AMUR::AmurSensors_WheelEncoders* wheelencoders);
  ::AMUR::AmurSensors_WheelEncoders* unsafe_arena_release_wheelencoders();

  // .AMUR.AmurSensors.HandEncoders handEncoders = 5;
  bool has_handencoders() const;
  private:
  bool _internal_has_handencoders() const;
  public:
  void clear_handencoders();
  const ::AMUR::AmurSensors_HandEncoders& handencoders() const;
  ::AMUR::AmurSensors_HandEncoders* release_handencoders();
  ::AMUR::AmurSensors_HandEncoders* mutable_handencoders();
  void set_allocated_handencoders(::AMUR::AmurSensors_HandEncoders* handencoders);
  private:
  const ::AMUR::AmurSensors_HandEncoders& _internal_handencoders() const;
  ::AMUR::AmurSensors_HandEncoders* _internal_mutable_handencoders();
  public:
  void unsafe_arena_set_allocated_handencoders(
      ::AMUR::AmurSensors_HandEncoders* handencoders);
  ::AMUR::AmurSensors_HandEncoders* unsafe_arena_release_handencoders();

  // .AMUR.AmurSensors.Temperature temperature = 6;
  bool has_temperature() const;
  private:
  bool _internal_has_temperature() const;
  public:
  void clear_temperature();
  const ::AMUR::AmurSensors_Temperature& temperature() const;
  ::AMUR::AmurSensors_Temperature* release_temperature();
  ::AMUR::AmurSensors_Temperature* mutable_temperature();
  void set_allocated_temperature(::AMUR::AmurSensors_Temperature* temperature);
  private:
  const ::AMUR::AmurSensors_Temperature& _internal_temperature() const;
  ::AMUR::AmurSensors_Temperature* _internal_mutable_temperature();
  public:
  void unsafe_arena_set_allocated_temperature(
      ::AMUR::AmurSensors_Temperature* temperature);
  ::AMUR::AmurSensors_Temperature* unsafe_arena_release_temperature();

  // .AMUR.AmurSensors.Misc misc = 7;
  bool has_misc() const;
  private:
  bool _internal_has_misc() const;
  public:
  void clear_misc();
  const ::AMUR::AmurSensors_Misc& misc() const;
  ::AMUR::AmurSensors_Misc* release_misc();
  ::AMUR::AmurSensors_Misc* mutable_misc();
  void set_allocated_misc(::AMUR::AmurSensors_Misc* misc);
  private:
  const ::AMUR::AmurSensors_Misc& _internal_misc() const;
  ::AMUR::AmurSensors_Misc* _internal_mutable_misc();
  public:
  void unsafe_arena_set_allocated_misc(
      ::AMUR::AmurSensors_Misc* misc);
  ::AMUR::AmurSensors_Misc* unsafe_arena_release_misc();

  // @@protoc_insertion_point(class_scope:AMUR.AmurSensors)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::AMUR::AmurSensors_Accelerometer* accelerometer_;
  ::AMUR::AmurSensors_Gyroscope* gyroscope_;
  ::AMUR::AmurSensors_Magnitometer* magnitometer_;
  ::AMUR::AmurSensors_WheelEncoders* wheelencoders_;
  ::AMUR::AmurSensors_HandEncoders* handencoders_;
  ::AMUR::AmurSensors_Temperature* temperature_;
  ::AMUR::AmurSensors_Misc* misc_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_amur_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AmurControls_CameraServos

// int32 xAngle = 1;
inline void AmurControls_CameraServos::clear_xangle() {
  xangle_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_CameraServos::_internal_xangle() const {
  return xangle_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_CameraServos::xangle() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurControls.CameraServos.xAngle)
  return _internal_xangle();
}
inline void AmurControls_CameraServos::_internal_set_xangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  xangle_ = value;
}
inline void AmurControls_CameraServos::set_xangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_xangle(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurControls.CameraServos.xAngle)
}

// int32 yAngle = 2;
inline void AmurControls_CameraServos::clear_yangle() {
  yangle_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_CameraServos::_internal_yangle() const {
  return yangle_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_CameraServos::yangle() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurControls.CameraServos.yAngle)
  return _internal_yangle();
}
inline void AmurControls_CameraServos::_internal_set_yangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  yangle_ = value;
}
inline void AmurControls_CameraServos::set_yangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_yangle(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurControls.CameraServos.yAngle)
}

// -------------------------------------------------------------------

// AmurControls_WheelMotors

// int32 leftPower = 1;
inline void AmurControls_WheelMotors::clear_leftpower() {
  leftpower_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_WheelMotors::_internal_leftpower() const {
  return leftpower_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_WheelMotors::leftpower() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurControls.WheelMotors.leftPower)
  return _internal_leftpower();
}
inline void AmurControls_WheelMotors::_internal_set_leftpower(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  leftpower_ = value;
}
inline void AmurControls_WheelMotors::set_leftpower(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_leftpower(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurControls.WheelMotors.leftPower)
}

// uint32 leftTime = 2;
inline void AmurControls_WheelMotors::clear_lefttime() {
  lefttime_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AmurControls_WheelMotors::_internal_lefttime() const {
  return lefttime_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AmurControls_WheelMotors::lefttime() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurControls.WheelMotors.leftTime)
  return _internal_lefttime();
}
inline void AmurControls_WheelMotors::_internal_set_lefttime(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  lefttime_ = value;
}
inline void AmurControls_WheelMotors::set_lefttime(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_lefttime(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurControls.WheelMotors.leftTime)
}

// int32 rightPower = 3;
inline void AmurControls_WheelMotors::clear_rightpower() {
  rightpower_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_WheelMotors::_internal_rightpower() const {
  return rightpower_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_WheelMotors::rightpower() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurControls.WheelMotors.rightPower)
  return _internal_rightpower();
}
inline void AmurControls_WheelMotors::_internal_set_rightpower(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  rightpower_ = value;
}
inline void AmurControls_WheelMotors::set_rightpower(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rightpower(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurControls.WheelMotors.rightPower)
}

// uint32 rightTime = 4;
inline void AmurControls_WheelMotors::clear_righttime() {
  righttime_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AmurControls_WheelMotors::_internal_righttime() const {
  return righttime_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AmurControls_WheelMotors::righttime() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurControls.WheelMotors.rightTime)
  return _internal_righttime();
}
inline void AmurControls_WheelMotors::_internal_set_righttime(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  righttime_ = value;
}
inline void AmurControls_WheelMotors::set_righttime(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_righttime(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurControls.WheelMotors.rightTime)
}

// -------------------------------------------------------------------

// AmurControls_HandMotors

// int32 leftPower = 1;
inline void AmurControls_HandMotors::clear_leftpower() {
  leftpower_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_HandMotors::_internal_leftpower() const {
  return leftpower_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_HandMotors::leftpower() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurControls.HandMotors.leftPower)
  return _internal_leftpower();
}
inline void AmurControls_HandMotors::_internal_set_leftpower(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  leftpower_ = value;
}
inline void AmurControls_HandMotors::set_leftpower(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_leftpower(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurControls.HandMotors.leftPower)
}

// uint32 leftTime = 2;
inline void AmurControls_HandMotors::clear_lefttime() {
  lefttime_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AmurControls_HandMotors::_internal_lefttime() const {
  return lefttime_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AmurControls_HandMotors::lefttime() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurControls.HandMotors.leftTime)
  return _internal_lefttime();
}
inline void AmurControls_HandMotors::_internal_set_lefttime(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  lefttime_ = value;
}
inline void AmurControls_HandMotors::set_lefttime(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_lefttime(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurControls.HandMotors.leftTime)
}

// int32 rightPower = 3;
inline void AmurControls_HandMotors::clear_rightpower() {
  rightpower_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_HandMotors::_internal_rightpower() const {
  return rightpower_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_HandMotors::rightpower() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurControls.HandMotors.rightPower)
  return _internal_rightpower();
}
inline void AmurControls_HandMotors::_internal_set_rightpower(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  rightpower_ = value;
}
inline void AmurControls_HandMotors::set_rightpower(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rightpower(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurControls.HandMotors.rightPower)
}

// uint32 rightTime = 4;
inline void AmurControls_HandMotors::clear_righttime() {
  righttime_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AmurControls_HandMotors::_internal_righttime() const {
  return righttime_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AmurControls_HandMotors::righttime() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurControls.HandMotors.rightTime)
  return _internal_righttime();
}
inline void AmurControls_HandMotors::_internal_set_righttime(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  righttime_ = value;
}
inline void AmurControls_HandMotors::set_righttime(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_righttime(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurControls.HandMotors.rightTime)
}

// bool leftRelay = 5;
inline void AmurControls_HandMotors::clear_leftrelay() {
  leftrelay_ = false;
}
inline bool AmurControls_HandMotors::_internal_leftrelay() const {
  return leftrelay_;
}
inline bool AmurControls_HandMotors::leftrelay() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurControls.HandMotors.leftRelay)
  return _internal_leftrelay();
}
inline void AmurControls_HandMotors::_internal_set_leftrelay(bool value) {
  
  leftrelay_ = value;
}
inline void AmurControls_HandMotors::set_leftrelay(bool value) {
  _internal_set_leftrelay(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurControls.HandMotors.leftRelay)
}

// bool rightRelay = 6;
inline void AmurControls_HandMotors::clear_rightrelay() {
  rightrelay_ = false;
}
inline bool AmurControls_HandMotors::_internal_rightrelay() const {
  return rightrelay_;
}
inline bool AmurControls_HandMotors::rightrelay() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurControls.HandMotors.rightRelay)
  return _internal_rightrelay();
}
inline void AmurControls_HandMotors::_internal_set_rightrelay(bool value) {
  
  rightrelay_ = value;
}
inline void AmurControls_HandMotors::set_rightrelay(bool value) {
  _internal_set_rightrelay(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurControls.HandMotors.rightRelay)
}

// -------------------------------------------------------------------

// AmurControls_Light

// uint32 ledLeftPower = 1;
inline void AmurControls_Light::clear_ledleftpower() {
  ledleftpower_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AmurControls_Light::_internal_ledleftpower() const {
  return ledleftpower_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AmurControls_Light::ledleftpower() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurControls.Light.ledLeftPower)
  return _internal_ledleftpower();
}
inline void AmurControls_Light::_internal_set_ledleftpower(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  ledleftpower_ = value;
}
inline void AmurControls_Light::set_ledleftpower(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_ledleftpower(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurControls.Light.ledLeftPower)
}

// uint32 ledRightPower = 2;
inline void AmurControls_Light::clear_ledrightpower() {
  ledrightpower_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AmurControls_Light::_internal_ledrightpower() const {
  return ledrightpower_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AmurControls_Light::ledrightpower() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurControls.Light.ledRightPower)
  return _internal_ledrightpower();
}
inline void AmurControls_Light::_internal_set_ledrightpower(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  ledrightpower_ = value;
}
inline void AmurControls_Light::set_ledrightpower(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_ledrightpower(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurControls.Light.ledRightPower)
}

// -------------------------------------------------------------------

// AmurControls_System

// bool haltFlag = 1;
inline void AmurControls_System::clear_haltflag() {
  haltflag_ = false;
}
inline bool AmurControls_System::_internal_haltflag() const {
  return haltflag_;
}
inline bool AmurControls_System::haltflag() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurControls.System.haltFlag)
  return _internal_haltflag();
}
inline void AmurControls_System::_internal_set_haltflag(bool value) {
  
  haltflag_ = value;
}
inline void AmurControls_System::set_haltflag(bool value) {
  _internal_set_haltflag(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurControls.System.haltFlag)
}

// bool restartFlag = 2;
inline void AmurControls_System::clear_restartflag() {
  restartflag_ = false;
}
inline bool AmurControls_System::_internal_restartflag() const {
  return restartflag_;
}
inline bool AmurControls_System::restartflag() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurControls.System.restartFlag)
  return _internal_restartflag();
}
inline void AmurControls_System::_internal_set_restartflag(bool value) {
  
  restartflag_ = value;
}
inline void AmurControls_System::set_restartflag(bool value) {
  _internal_set_restartflag(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurControls.System.restartFlag)
}

// string timeOnAmur = 3;
inline void AmurControls_System::clear_timeonamur() {
  timeonamur_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& AmurControls_System::timeonamur() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurControls.System.timeOnAmur)
  return _internal_timeonamur();
}
inline void AmurControls_System::set_timeonamur(const std::string& value) {
  _internal_set_timeonamur(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurControls.System.timeOnAmur)
}
inline std::string* AmurControls_System::mutable_timeonamur() {
  // @@protoc_insertion_point(field_mutable:AMUR.AmurControls.System.timeOnAmur)
  return _internal_mutable_timeonamur();
}
inline const std::string& AmurControls_System::_internal_timeonamur() const {
  return timeonamur_.Get();
}
inline void AmurControls_System::_internal_set_timeonamur(const std::string& value) {
  
  timeonamur_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AmurControls_System::set_timeonamur(std::string&& value) {
  
  timeonamur_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:AMUR.AmurControls.System.timeOnAmur)
}
inline void AmurControls_System::set_timeonamur(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  timeonamur_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:AMUR.AmurControls.System.timeOnAmur)
}
inline void AmurControls_System::set_timeonamur(const char* value,
    size_t size) {
  
  timeonamur_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:AMUR.AmurControls.System.timeOnAmur)
}
inline std::string* AmurControls_System::_internal_mutable_timeonamur() {
  
  return timeonamur_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AmurControls_System::release_timeonamur() {
  // @@protoc_insertion_point(field_release:AMUR.AmurControls.System.timeOnAmur)
  return timeonamur_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AmurControls_System::set_allocated_timeonamur(std::string* timeonamur) {
  if (timeonamur != nullptr) {
    
  } else {
    
  }
  timeonamur_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), timeonamur,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:AMUR.AmurControls.System.timeOnAmur)
}
inline std::string* AmurControls_System::unsafe_arena_release_timeonamur() {
  // @@protoc_insertion_point(field_unsafe_arena_release:AMUR.AmurControls.System.timeOnAmur)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return timeonamur_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void AmurControls_System::unsafe_arena_set_allocated_timeonamur(
    std::string* timeonamur) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (timeonamur != nullptr) {
    
  } else {
    
  }
  timeonamur_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      timeonamur, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AMUR.AmurControls.System.timeOnAmur)
}

// -------------------------------------------------------------------

// AmurControls

// .AMUR.AmurControls.CameraServos cameraServos = 1;
inline bool AmurControls::_internal_has_cameraservos() const {
  return this != internal_default_instance() && cameraservos_ != nullptr;
}
inline bool AmurControls::has_cameraservos() const {
  return _internal_has_cameraservos();
}
inline void AmurControls::clear_cameraservos() {
  if (GetArena() == nullptr && cameraservos_ != nullptr) {
    delete cameraservos_;
  }
  cameraservos_ = nullptr;
}
inline const ::AMUR::AmurControls_CameraServos& AmurControls::_internal_cameraservos() const {
  const ::AMUR::AmurControls_CameraServos* p = cameraservos_;
  return p != nullptr ? *p : *reinterpret_cast<const ::AMUR::AmurControls_CameraServos*>(
      &::AMUR::_AmurControls_CameraServos_default_instance_);
}
inline const ::AMUR::AmurControls_CameraServos& AmurControls::cameraservos() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurControls.cameraServos)
  return _internal_cameraservos();
}
inline void AmurControls::unsafe_arena_set_allocated_cameraservos(
    ::AMUR::AmurControls_CameraServos* cameraservos) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cameraservos_);
  }
  cameraservos_ = cameraservos;
  if (cameraservos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AMUR.AmurControls.cameraServos)
}
inline ::AMUR::AmurControls_CameraServos* AmurControls::release_cameraservos() {
  auto temp = unsafe_arena_release_cameraservos();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::AMUR::AmurControls_CameraServos* AmurControls::unsafe_arena_release_cameraservos() {
  // @@protoc_insertion_point(field_release:AMUR.AmurControls.cameraServos)
  
  ::AMUR::AmurControls_CameraServos* temp = cameraservos_;
  cameraservos_ = nullptr;
  return temp;
}
inline ::AMUR::AmurControls_CameraServos* AmurControls::_internal_mutable_cameraservos() {
  
  if (cameraservos_ == nullptr) {
    auto* p = CreateMaybeMessage<::AMUR::AmurControls_CameraServos>(GetArena());
    cameraservos_ = p;
  }
  return cameraservos_;
}
inline ::AMUR::AmurControls_CameraServos* AmurControls::mutable_cameraservos() {
  // @@protoc_insertion_point(field_mutable:AMUR.AmurControls.cameraServos)
  return _internal_mutable_cameraservos();
}
inline void AmurControls::set_allocated_cameraservos(::AMUR::AmurControls_CameraServos* cameraservos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete cameraservos_;
  }
  if (cameraservos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(cameraservos);
    if (message_arena != submessage_arena) {
      cameraservos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cameraservos, submessage_arena);
    }
    
  } else {
    
  }
  cameraservos_ = cameraservos;
  // @@protoc_insertion_point(field_set_allocated:AMUR.AmurControls.cameraServos)
}

// .AMUR.AmurControls.WheelMotors wheelMotors = 2;
inline bool AmurControls::_internal_has_wheelmotors() const {
  return this != internal_default_instance() && wheelmotors_ != nullptr;
}
inline bool AmurControls::has_wheelmotors() const {
  return _internal_has_wheelmotors();
}
inline void AmurControls::clear_wheelmotors() {
  if (GetArena() == nullptr && wheelmotors_ != nullptr) {
    delete wheelmotors_;
  }
  wheelmotors_ = nullptr;
}
inline const ::AMUR::AmurControls_WheelMotors& AmurControls::_internal_wheelmotors() const {
  const ::AMUR::AmurControls_WheelMotors* p = wheelmotors_;
  return p != nullptr ? *p : *reinterpret_cast<const ::AMUR::AmurControls_WheelMotors*>(
      &::AMUR::_AmurControls_WheelMotors_default_instance_);
}
inline const ::AMUR::AmurControls_WheelMotors& AmurControls::wheelmotors() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurControls.wheelMotors)
  return _internal_wheelmotors();
}
inline void AmurControls::unsafe_arena_set_allocated_wheelmotors(
    ::AMUR::AmurControls_WheelMotors* wheelmotors) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wheelmotors_);
  }
  wheelmotors_ = wheelmotors;
  if (wheelmotors) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AMUR.AmurControls.wheelMotors)
}
inline ::AMUR::AmurControls_WheelMotors* AmurControls::release_wheelmotors() {
  auto temp = unsafe_arena_release_wheelmotors();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::AMUR::AmurControls_WheelMotors* AmurControls::unsafe_arena_release_wheelmotors() {
  // @@protoc_insertion_point(field_release:AMUR.AmurControls.wheelMotors)
  
  ::AMUR::AmurControls_WheelMotors* temp = wheelmotors_;
  wheelmotors_ = nullptr;
  return temp;
}
inline ::AMUR::AmurControls_WheelMotors* AmurControls::_internal_mutable_wheelmotors() {
  
  if (wheelmotors_ == nullptr) {
    auto* p = CreateMaybeMessage<::AMUR::AmurControls_WheelMotors>(GetArena());
    wheelmotors_ = p;
  }
  return wheelmotors_;
}
inline ::AMUR::AmurControls_WheelMotors* AmurControls::mutable_wheelmotors() {
  // @@protoc_insertion_point(field_mutable:AMUR.AmurControls.wheelMotors)
  return _internal_mutable_wheelmotors();
}
inline void AmurControls::set_allocated_wheelmotors(::AMUR::AmurControls_WheelMotors* wheelmotors) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete wheelmotors_;
  }
  if (wheelmotors) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(wheelmotors);
    if (message_arena != submessage_arena) {
      wheelmotors = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wheelmotors, submessage_arena);
    }
    
  } else {
    
  }
  wheelmotors_ = wheelmotors;
  // @@protoc_insertion_point(field_set_allocated:AMUR.AmurControls.wheelMotors)
}

// .AMUR.AmurControls.HandMotors handMotors = 3;
inline bool AmurControls::_internal_has_handmotors() const {
  return this != internal_default_instance() && handmotors_ != nullptr;
}
inline bool AmurControls::has_handmotors() const {
  return _internal_has_handmotors();
}
inline void AmurControls::clear_handmotors() {
  if (GetArena() == nullptr && handmotors_ != nullptr) {
    delete handmotors_;
  }
  handmotors_ = nullptr;
}
inline const ::AMUR::AmurControls_HandMotors& AmurControls::_internal_handmotors() const {
  const ::AMUR::AmurControls_HandMotors* p = handmotors_;
  return p != nullptr ? *p : *reinterpret_cast<const ::AMUR::AmurControls_HandMotors*>(
      &::AMUR::_AmurControls_HandMotors_default_instance_);
}
inline const ::AMUR::AmurControls_HandMotors& AmurControls::handmotors() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurControls.handMotors)
  return _internal_handmotors();
}
inline void AmurControls::unsafe_arena_set_allocated_handmotors(
    ::AMUR::AmurControls_HandMotors* handmotors) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handmotors_);
  }
  handmotors_ = handmotors;
  if (handmotors) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AMUR.AmurControls.handMotors)
}
inline ::AMUR::AmurControls_HandMotors* AmurControls::release_handmotors() {
  auto temp = unsafe_arena_release_handmotors();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::AMUR::AmurControls_HandMotors* AmurControls::unsafe_arena_release_handmotors() {
  // @@protoc_insertion_point(field_release:AMUR.AmurControls.handMotors)
  
  ::AMUR::AmurControls_HandMotors* temp = handmotors_;
  handmotors_ = nullptr;
  return temp;
}
inline ::AMUR::AmurControls_HandMotors* AmurControls::_internal_mutable_handmotors() {
  
  if (handmotors_ == nullptr) {
    auto* p = CreateMaybeMessage<::AMUR::AmurControls_HandMotors>(GetArena());
    handmotors_ = p;
  }
  return handmotors_;
}
inline ::AMUR::AmurControls_HandMotors* AmurControls::mutable_handmotors() {
  // @@protoc_insertion_point(field_mutable:AMUR.AmurControls.handMotors)
  return _internal_mutable_handmotors();
}
inline void AmurControls::set_allocated_handmotors(::AMUR::AmurControls_HandMotors* handmotors) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete handmotors_;
  }
  if (handmotors) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(handmotors);
    if (message_arena != submessage_arena) {
      handmotors = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handmotors, submessage_arena);
    }
    
  } else {
    
  }
  handmotors_ = handmotors;
  // @@protoc_insertion_point(field_set_allocated:AMUR.AmurControls.handMotors)
}

// .AMUR.AmurControls.Light light = 4;
inline bool AmurControls::_internal_has_light() const {
  return this != internal_default_instance() && light_ != nullptr;
}
inline bool AmurControls::has_light() const {
  return _internal_has_light();
}
inline void AmurControls::clear_light() {
  if (GetArena() == nullptr && light_ != nullptr) {
    delete light_;
  }
  light_ = nullptr;
}
inline const ::AMUR::AmurControls_Light& AmurControls::_internal_light() const {
  const ::AMUR::AmurControls_Light* p = light_;
  return p != nullptr ? *p : *reinterpret_cast<const ::AMUR::AmurControls_Light*>(
      &::AMUR::_AmurControls_Light_default_instance_);
}
inline const ::AMUR::AmurControls_Light& AmurControls::light() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurControls.light)
  return _internal_light();
}
inline void AmurControls::unsafe_arena_set_allocated_light(
    ::AMUR::AmurControls_Light* light) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(light_);
  }
  light_ = light;
  if (light) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AMUR.AmurControls.light)
}
inline ::AMUR::AmurControls_Light* AmurControls::release_light() {
  auto temp = unsafe_arena_release_light();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::AMUR::AmurControls_Light* AmurControls::unsafe_arena_release_light() {
  // @@protoc_insertion_point(field_release:AMUR.AmurControls.light)
  
  ::AMUR::AmurControls_Light* temp = light_;
  light_ = nullptr;
  return temp;
}
inline ::AMUR::AmurControls_Light* AmurControls::_internal_mutable_light() {
  
  if (light_ == nullptr) {
    auto* p = CreateMaybeMessage<::AMUR::AmurControls_Light>(GetArena());
    light_ = p;
  }
  return light_;
}
inline ::AMUR::AmurControls_Light* AmurControls::mutable_light() {
  // @@protoc_insertion_point(field_mutable:AMUR.AmurControls.light)
  return _internal_mutable_light();
}
inline void AmurControls::set_allocated_light(::AMUR::AmurControls_Light* light) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete light_;
  }
  if (light) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(light);
    if (message_arena != submessage_arena) {
      light = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, light, submessage_arena);
    }
    
  } else {
    
  }
  light_ = light;
  // @@protoc_insertion_point(field_set_allocated:AMUR.AmurControls.light)
}

// .AMUR.AmurControls.System system = 5;
inline bool AmurControls::_internal_has_system() const {
  return this != internal_default_instance() && system_ != nullptr;
}
inline bool AmurControls::has_system() const {
  return _internal_has_system();
}
inline void AmurControls::clear_system() {
  if (GetArena() == nullptr && system_ != nullptr) {
    delete system_;
  }
  system_ = nullptr;
}
inline const ::AMUR::AmurControls_System& AmurControls::_internal_system() const {
  const ::AMUR::AmurControls_System* p = system_;
  return p != nullptr ? *p : *reinterpret_cast<const ::AMUR::AmurControls_System*>(
      &::AMUR::_AmurControls_System_default_instance_);
}
inline const ::AMUR::AmurControls_System& AmurControls::system() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurControls.system)
  return _internal_system();
}
inline void AmurControls::unsafe_arena_set_allocated_system(
    ::AMUR::AmurControls_System* system) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(system_);
  }
  system_ = system;
  if (system) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AMUR.AmurControls.system)
}
inline ::AMUR::AmurControls_System* AmurControls::release_system() {
  auto temp = unsafe_arena_release_system();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::AMUR::AmurControls_System* AmurControls::unsafe_arena_release_system() {
  // @@protoc_insertion_point(field_release:AMUR.AmurControls.system)
  
  ::AMUR::AmurControls_System* temp = system_;
  system_ = nullptr;
  return temp;
}
inline ::AMUR::AmurControls_System* AmurControls::_internal_mutable_system() {
  
  if (system_ == nullptr) {
    auto* p = CreateMaybeMessage<::AMUR::AmurControls_System>(GetArena());
    system_ = p;
  }
  return system_;
}
inline ::AMUR::AmurControls_System* AmurControls::mutable_system() {
  // @@protoc_insertion_point(field_mutable:AMUR.AmurControls.system)
  return _internal_mutable_system();
}
inline void AmurControls::set_allocated_system(::AMUR::AmurControls_System* system) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete system_;
  }
  if (system) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(system);
    if (message_arena != submessage_arena) {
      system = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, system, submessage_arena);
    }
    
  } else {
    
  }
  system_ = system;
  // @@protoc_insertion_point(field_set_allocated:AMUR.AmurControls.system)
}

// -------------------------------------------------------------------

// AmurSensors_Accelerometer

// float x = 1;
inline void AmurSensors_Accelerometer::clear_x() {
  x_ = 0;
}
inline float AmurSensors_Accelerometer::_internal_x() const {
  return x_;
}
inline float AmurSensors_Accelerometer::x() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.Accelerometer.x)
  return _internal_x();
}
inline void AmurSensors_Accelerometer::_internal_set_x(float value) {
  
  x_ = value;
}
inline void AmurSensors_Accelerometer::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurSensors.Accelerometer.x)
}

// float y = 2;
inline void AmurSensors_Accelerometer::clear_y() {
  y_ = 0;
}
inline float AmurSensors_Accelerometer::_internal_y() const {
  return y_;
}
inline float AmurSensors_Accelerometer::y() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.Accelerometer.y)
  return _internal_y();
}
inline void AmurSensors_Accelerometer::_internal_set_y(float value) {
  
  y_ = value;
}
inline void AmurSensors_Accelerometer::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurSensors.Accelerometer.y)
}

// float z = 3;
inline void AmurSensors_Accelerometer::clear_z() {
  z_ = 0;
}
inline float AmurSensors_Accelerometer::_internal_z() const {
  return z_;
}
inline float AmurSensors_Accelerometer::z() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.Accelerometer.z)
  return _internal_z();
}
inline void AmurSensors_Accelerometer::_internal_set_z(float value) {
  
  z_ = value;
}
inline void AmurSensors_Accelerometer::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurSensors.Accelerometer.z)
}

// -------------------------------------------------------------------

// AmurSensors_Gyroscope

// float x = 1;
inline void AmurSensors_Gyroscope::clear_x() {
  x_ = 0;
}
inline float AmurSensors_Gyroscope::_internal_x() const {
  return x_;
}
inline float AmurSensors_Gyroscope::x() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.Gyroscope.x)
  return _internal_x();
}
inline void AmurSensors_Gyroscope::_internal_set_x(float value) {
  
  x_ = value;
}
inline void AmurSensors_Gyroscope::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurSensors.Gyroscope.x)
}

// float y = 2;
inline void AmurSensors_Gyroscope::clear_y() {
  y_ = 0;
}
inline float AmurSensors_Gyroscope::_internal_y() const {
  return y_;
}
inline float AmurSensors_Gyroscope::y() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.Gyroscope.y)
  return _internal_y();
}
inline void AmurSensors_Gyroscope::_internal_set_y(float value) {
  
  y_ = value;
}
inline void AmurSensors_Gyroscope::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurSensors.Gyroscope.y)
}

// float z = 3;
inline void AmurSensors_Gyroscope::clear_z() {
  z_ = 0;
}
inline float AmurSensors_Gyroscope::_internal_z() const {
  return z_;
}
inline float AmurSensors_Gyroscope::z() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.Gyroscope.z)
  return _internal_z();
}
inline void AmurSensors_Gyroscope::_internal_set_z(float value) {
  
  z_ = value;
}
inline void AmurSensors_Gyroscope::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurSensors.Gyroscope.z)
}

// -------------------------------------------------------------------

// AmurSensors_Magnitometer

// float x = 1;
inline void AmurSensors_Magnitometer::clear_x() {
  x_ = 0;
}
inline float AmurSensors_Magnitometer::_internal_x() const {
  return x_;
}
inline float AmurSensors_Magnitometer::x() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.Magnitometer.x)
  return _internal_x();
}
inline void AmurSensors_Magnitometer::_internal_set_x(float value) {
  
  x_ = value;
}
inline void AmurSensors_Magnitometer::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurSensors.Magnitometer.x)
}

// float y = 2;
inline void AmurSensors_Magnitometer::clear_y() {
  y_ = 0;
}
inline float AmurSensors_Magnitometer::_internal_y() const {
  return y_;
}
inline float AmurSensors_Magnitometer::y() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.Magnitometer.y)
  return _internal_y();
}
inline void AmurSensors_Magnitometer::_internal_set_y(float value) {
  
  y_ = value;
}
inline void AmurSensors_Magnitometer::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurSensors.Magnitometer.y)
}

// float z = 3;
inline void AmurSensors_Magnitometer::clear_z() {
  z_ = 0;
}
inline float AmurSensors_Magnitometer::_internal_z() const {
  return z_;
}
inline float AmurSensors_Magnitometer::z() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.Magnitometer.z)
  return _internal_z();
}
inline void AmurSensors_Magnitometer::_internal_set_z(float value) {
  
  z_ = value;
}
inline void AmurSensors_Magnitometer::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurSensors.Magnitometer.z)
}

// -------------------------------------------------------------------

// AmurSensors_WheelEncoders

// int32 leftAngle = 1;
inline void AmurSensors_WheelEncoders::clear_leftangle() {
  leftangle_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_WheelEncoders::_internal_leftangle() const {
  return leftangle_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_WheelEncoders::leftangle() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.WheelEncoders.leftAngle)
  return _internal_leftangle();
}
inline void AmurSensors_WheelEncoders::_internal_set_leftangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  leftangle_ = value;
}
inline void AmurSensors_WheelEncoders::set_leftangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_leftangle(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurSensors.WheelEncoders.leftAngle)
}

// int32 rightAngle = 2;
inline void AmurSensors_WheelEncoders::clear_rightangle() {
  rightangle_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_WheelEncoders::_internal_rightangle() const {
  return rightangle_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_WheelEncoders::rightangle() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.WheelEncoders.rightAngle)
  return _internal_rightangle();
}
inline void AmurSensors_WheelEncoders::_internal_set_rightangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  rightangle_ = value;
}
inline void AmurSensors_WheelEncoders::set_rightangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rightangle(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurSensors.WheelEncoders.rightAngle)
}

// -------------------------------------------------------------------

// AmurSensors_HandEncoders

// int32 leftInternalAngle = 1;
inline void AmurSensors_HandEncoders::clear_leftinternalangle() {
  leftinternalangle_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_HandEncoders::_internal_leftinternalangle() const {
  return leftinternalangle_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_HandEncoders::leftinternalangle() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.HandEncoders.leftInternalAngle)
  return _internal_leftinternalangle();
}
inline void AmurSensors_HandEncoders::_internal_set_leftinternalangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  leftinternalangle_ = value;
}
inline void AmurSensors_HandEncoders::set_leftinternalangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_leftinternalangle(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurSensors.HandEncoders.leftInternalAngle)
}

// int32 rightInternalAngle = 2;
inline void AmurSensors_HandEncoders::clear_rightinternalangle() {
  rightinternalangle_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_HandEncoders::_internal_rightinternalangle() const {
  return rightinternalangle_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_HandEncoders::rightinternalangle() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.HandEncoders.rightInternalAngle)
  return _internal_rightinternalangle();
}
inline void AmurSensors_HandEncoders::_internal_set_rightinternalangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  rightinternalangle_ = value;
}
inline void AmurSensors_HandEncoders::set_rightinternalangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rightinternalangle(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurSensors.HandEncoders.rightInternalAngle)
}

// int32 leftOuterAngle = 3;
inline void AmurSensors_HandEncoders::clear_leftouterangle() {
  leftouterangle_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_HandEncoders::_internal_leftouterangle() const {
  return leftouterangle_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_HandEncoders::leftouterangle() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.HandEncoders.leftOuterAngle)
  return _internal_leftouterangle();
}
inline void AmurSensors_HandEncoders::_internal_set_leftouterangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  leftouterangle_ = value;
}
inline void AmurSensors_HandEncoders::set_leftouterangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_leftouterangle(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurSensors.HandEncoders.leftOuterAngle)
}

// int32 rightOuterAngle = 4;
inline void AmurSensors_HandEncoders::clear_rightouterangle() {
  rightouterangle_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_HandEncoders::_internal_rightouterangle() const {
  return rightouterangle_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_HandEncoders::rightouterangle() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.HandEncoders.rightOuterAngle)
  return _internal_rightouterangle();
}
inline void AmurSensors_HandEncoders::_internal_set_rightouterangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  rightouterangle_ = value;
}
inline void AmurSensors_HandEncoders::set_rightouterangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rightouterangle(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurSensors.HandEncoders.rightOuterAngle)
}

// -------------------------------------------------------------------

// AmurSensors_Temperature

// int32 tempAccelerometer = 1;
inline void AmurSensors_Temperature::clear_tempaccelerometer() {
  tempaccelerometer_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_Temperature::_internal_tempaccelerometer() const {
  return tempaccelerometer_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_Temperature::tempaccelerometer() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.Temperature.tempAccelerometer)
  return _internal_tempaccelerometer();
}
inline void AmurSensors_Temperature::_internal_set_tempaccelerometer(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  tempaccelerometer_ = value;
}
inline void AmurSensors_Temperature::set_tempaccelerometer(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_tempaccelerometer(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurSensors.Temperature.tempAccelerometer)
}

// int32 tempCPU = 2;
inline void AmurSensors_Temperature::clear_tempcpu() {
  tempcpu_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_Temperature::_internal_tempcpu() const {
  return tempcpu_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_Temperature::tempcpu() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.Temperature.tempCPU)
  return _internal_tempcpu();
}
inline void AmurSensors_Temperature::_internal_set_tempcpu(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  tempcpu_ = value;
}
inline void AmurSensors_Temperature::set_tempcpu(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_tempcpu(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurSensors.Temperature.tempCPU)
}

// int32 tempPressure = 3;
inline void AmurSensors_Temperature::clear_temppressure() {
  temppressure_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_Temperature::_internal_temppressure() const {
  return temppressure_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_Temperature::temppressure() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.Temperature.tempPressure)
  return _internal_temppressure();
}
inline void AmurSensors_Temperature::_internal_set_temppressure(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  temppressure_ = value;
}
inline void AmurSensors_Temperature::set_temppressure(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_temppressure(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurSensors.Temperature.tempPressure)
}

// -------------------------------------------------------------------

// AmurSensors_WheelCurrent

// uint32 leftCurrent = 1;
inline void AmurSensors_WheelCurrent::clear_leftcurrent() {
  leftcurrent_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AmurSensors_WheelCurrent::_internal_leftcurrent() const {
  return leftcurrent_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AmurSensors_WheelCurrent::leftcurrent() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.WheelCurrent.leftCurrent)
  return _internal_leftcurrent();
}
inline void AmurSensors_WheelCurrent::_internal_set_leftcurrent(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  leftcurrent_ = value;
}
inline void AmurSensors_WheelCurrent::set_leftcurrent(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_leftcurrent(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurSensors.WheelCurrent.leftCurrent)
}

// uint32 rightCurrent = 2;
inline void AmurSensors_WheelCurrent::clear_rightcurrent() {
  rightcurrent_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AmurSensors_WheelCurrent::_internal_rightcurrent() const {
  return rightcurrent_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AmurSensors_WheelCurrent::rightcurrent() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.WheelCurrent.rightCurrent)
  return _internal_rightcurrent();
}
inline void AmurSensors_WheelCurrent::_internal_set_rightcurrent(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  rightcurrent_ = value;
}
inline void AmurSensors_WheelCurrent::set_rightcurrent(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_rightcurrent(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurSensors.WheelCurrent.rightCurrent)
}

// -------------------------------------------------------------------

// AmurSensors_HandCurrent

// uint32 leftCurrent = 1;
inline void AmurSensors_HandCurrent::clear_leftcurrent() {
  leftcurrent_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AmurSensors_HandCurrent::_internal_leftcurrent() const {
  return leftcurrent_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AmurSensors_HandCurrent::leftcurrent() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.HandCurrent.leftCurrent)
  return _internal_leftcurrent();
}
inline void AmurSensors_HandCurrent::_internal_set_leftcurrent(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  leftcurrent_ = value;
}
inline void AmurSensors_HandCurrent::set_leftcurrent(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_leftcurrent(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurSensors.HandCurrent.leftCurrent)
}

// uint32 rightCurrent = 2;
inline void AmurSensors_HandCurrent::clear_rightcurrent() {
  rightcurrent_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AmurSensors_HandCurrent::_internal_rightcurrent() const {
  return rightcurrent_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AmurSensors_HandCurrent::rightcurrent() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.HandCurrent.rightCurrent)
  return _internal_rightcurrent();
}
inline void AmurSensors_HandCurrent::_internal_set_rightcurrent(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  rightcurrent_ = value;
}
inline void AmurSensors_HandCurrent::set_rightcurrent(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_rightcurrent(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurSensors.HandCurrent.rightCurrent)
}

// -------------------------------------------------------------------

// AmurSensors_Misc

// int32 gas = 1;
inline void AmurSensors_Misc::clear_gas() {
  gas_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_Misc::_internal_gas() const {
  return gas_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_Misc::gas() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.Misc.gas)
  return _internal_gas();
}
inline void AmurSensors_Misc::_internal_set_gas(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  gas_ = value;
}
inline void AmurSensors_Misc::set_gas(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_gas(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurSensors.Misc.gas)
}

// int32 batteryVoltage = 2;
inline void AmurSensors_Misc::clear_batteryvoltage() {
  batteryvoltage_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_Misc::_internal_batteryvoltage() const {
  return batteryvoltage_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_Misc::batteryvoltage() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.Misc.batteryVoltage)
  return _internal_batteryvoltage();
}
inline void AmurSensors_Misc::_internal_set_batteryvoltage(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  batteryvoltage_ = value;
}
inline void AmurSensors_Misc::set_batteryvoltage(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_batteryvoltage(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurSensors.Misc.batteryVoltage)
}

// int32 raspberryVoltage = 3;
inline void AmurSensors_Misc::clear_raspberryvoltage() {
  raspberryvoltage_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_Misc::_internal_raspberryvoltage() const {
  return raspberryvoltage_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_Misc::raspberryvoltage() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.Misc.raspberryVoltage)
  return _internal_raspberryvoltage();
}
inline void AmurSensors_Misc::_internal_set_raspberryvoltage(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  raspberryvoltage_ = value;
}
inline void AmurSensors_Misc::set_raspberryvoltage(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_raspberryvoltage(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurSensors.Misc.raspberryVoltage)
}

// float pressure = 4;
inline void AmurSensors_Misc::clear_pressure() {
  pressure_ = 0;
}
inline float AmurSensors_Misc::_internal_pressure() const {
  return pressure_;
}
inline float AmurSensors_Misc::pressure() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.Misc.pressure)
  return _internal_pressure();
}
inline void AmurSensors_Misc::_internal_set_pressure(float value) {
  
  pressure_ = value;
}
inline void AmurSensors_Misc::set_pressure(float value) {
  _internal_set_pressure(value);
  // @@protoc_insertion_point(field_set:AMUR.AmurSensors.Misc.pressure)
}

// -------------------------------------------------------------------

// AmurSensors

// .AMUR.AmurSensors.Accelerometer accelerometer = 1;
inline bool AmurSensors::_internal_has_accelerometer() const {
  return this != internal_default_instance() && accelerometer_ != nullptr;
}
inline bool AmurSensors::has_accelerometer() const {
  return _internal_has_accelerometer();
}
inline void AmurSensors::clear_accelerometer() {
  if (GetArena() == nullptr && accelerometer_ != nullptr) {
    delete accelerometer_;
  }
  accelerometer_ = nullptr;
}
inline const ::AMUR::AmurSensors_Accelerometer& AmurSensors::_internal_accelerometer() const {
  const ::AMUR::AmurSensors_Accelerometer* p = accelerometer_;
  return p != nullptr ? *p : *reinterpret_cast<const ::AMUR::AmurSensors_Accelerometer*>(
      &::AMUR::_AmurSensors_Accelerometer_default_instance_);
}
inline const ::AMUR::AmurSensors_Accelerometer& AmurSensors::accelerometer() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.accelerometer)
  return _internal_accelerometer();
}
inline void AmurSensors::unsafe_arena_set_allocated_accelerometer(
    ::AMUR::AmurSensors_Accelerometer* accelerometer) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(accelerometer_);
  }
  accelerometer_ = accelerometer;
  if (accelerometer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AMUR.AmurSensors.accelerometer)
}
inline ::AMUR::AmurSensors_Accelerometer* AmurSensors::release_accelerometer() {
  auto temp = unsafe_arena_release_accelerometer();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::AMUR::AmurSensors_Accelerometer* AmurSensors::unsafe_arena_release_accelerometer() {
  // @@protoc_insertion_point(field_release:AMUR.AmurSensors.accelerometer)
  
  ::AMUR::AmurSensors_Accelerometer* temp = accelerometer_;
  accelerometer_ = nullptr;
  return temp;
}
inline ::AMUR::AmurSensors_Accelerometer* AmurSensors::_internal_mutable_accelerometer() {
  
  if (accelerometer_ == nullptr) {
    auto* p = CreateMaybeMessage<::AMUR::AmurSensors_Accelerometer>(GetArena());
    accelerometer_ = p;
  }
  return accelerometer_;
}
inline ::AMUR::AmurSensors_Accelerometer* AmurSensors::mutable_accelerometer() {
  // @@protoc_insertion_point(field_mutable:AMUR.AmurSensors.accelerometer)
  return _internal_mutable_accelerometer();
}
inline void AmurSensors::set_allocated_accelerometer(::AMUR::AmurSensors_Accelerometer* accelerometer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete accelerometer_;
  }
  if (accelerometer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(accelerometer);
    if (message_arena != submessage_arena) {
      accelerometer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, accelerometer, submessage_arena);
    }
    
  } else {
    
  }
  accelerometer_ = accelerometer;
  // @@protoc_insertion_point(field_set_allocated:AMUR.AmurSensors.accelerometer)
}

// .AMUR.AmurSensors.Gyroscope gyroscope = 2;
inline bool AmurSensors::_internal_has_gyroscope() const {
  return this != internal_default_instance() && gyroscope_ != nullptr;
}
inline bool AmurSensors::has_gyroscope() const {
  return _internal_has_gyroscope();
}
inline void AmurSensors::clear_gyroscope() {
  if (GetArena() == nullptr && gyroscope_ != nullptr) {
    delete gyroscope_;
  }
  gyroscope_ = nullptr;
}
inline const ::AMUR::AmurSensors_Gyroscope& AmurSensors::_internal_gyroscope() const {
  const ::AMUR::AmurSensors_Gyroscope* p = gyroscope_;
  return p != nullptr ? *p : *reinterpret_cast<const ::AMUR::AmurSensors_Gyroscope*>(
      &::AMUR::_AmurSensors_Gyroscope_default_instance_);
}
inline const ::AMUR::AmurSensors_Gyroscope& AmurSensors::gyroscope() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.gyroscope)
  return _internal_gyroscope();
}
inline void AmurSensors::unsafe_arena_set_allocated_gyroscope(
    ::AMUR::AmurSensors_Gyroscope* gyroscope) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gyroscope_);
  }
  gyroscope_ = gyroscope;
  if (gyroscope) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AMUR.AmurSensors.gyroscope)
}
inline ::AMUR::AmurSensors_Gyroscope* AmurSensors::release_gyroscope() {
  auto temp = unsafe_arena_release_gyroscope();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::AMUR::AmurSensors_Gyroscope* AmurSensors::unsafe_arena_release_gyroscope() {
  // @@protoc_insertion_point(field_release:AMUR.AmurSensors.gyroscope)
  
  ::AMUR::AmurSensors_Gyroscope* temp = gyroscope_;
  gyroscope_ = nullptr;
  return temp;
}
inline ::AMUR::AmurSensors_Gyroscope* AmurSensors::_internal_mutable_gyroscope() {
  
  if (gyroscope_ == nullptr) {
    auto* p = CreateMaybeMessage<::AMUR::AmurSensors_Gyroscope>(GetArena());
    gyroscope_ = p;
  }
  return gyroscope_;
}
inline ::AMUR::AmurSensors_Gyroscope* AmurSensors::mutable_gyroscope() {
  // @@protoc_insertion_point(field_mutable:AMUR.AmurSensors.gyroscope)
  return _internal_mutable_gyroscope();
}
inline void AmurSensors::set_allocated_gyroscope(::AMUR::AmurSensors_Gyroscope* gyroscope) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete gyroscope_;
  }
  if (gyroscope) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(gyroscope);
    if (message_arena != submessage_arena) {
      gyroscope = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gyroscope, submessage_arena);
    }
    
  } else {
    
  }
  gyroscope_ = gyroscope;
  // @@protoc_insertion_point(field_set_allocated:AMUR.AmurSensors.gyroscope)
}

// .AMUR.AmurSensors.Magnitometer magnitometer = 3;
inline bool AmurSensors::_internal_has_magnitometer() const {
  return this != internal_default_instance() && magnitometer_ != nullptr;
}
inline bool AmurSensors::has_magnitometer() const {
  return _internal_has_magnitometer();
}
inline void AmurSensors::clear_magnitometer() {
  if (GetArena() == nullptr && magnitometer_ != nullptr) {
    delete magnitometer_;
  }
  magnitometer_ = nullptr;
}
inline const ::AMUR::AmurSensors_Magnitometer& AmurSensors::_internal_magnitometer() const {
  const ::AMUR::AmurSensors_Magnitometer* p = magnitometer_;
  return p != nullptr ? *p : *reinterpret_cast<const ::AMUR::AmurSensors_Magnitometer*>(
      &::AMUR::_AmurSensors_Magnitometer_default_instance_);
}
inline const ::AMUR::AmurSensors_Magnitometer& AmurSensors::magnitometer() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.magnitometer)
  return _internal_magnitometer();
}
inline void AmurSensors::unsafe_arena_set_allocated_magnitometer(
    ::AMUR::AmurSensors_Magnitometer* magnitometer) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(magnitometer_);
  }
  magnitometer_ = magnitometer;
  if (magnitometer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AMUR.AmurSensors.magnitometer)
}
inline ::AMUR::AmurSensors_Magnitometer* AmurSensors::release_magnitometer() {
  auto temp = unsafe_arena_release_magnitometer();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::AMUR::AmurSensors_Magnitometer* AmurSensors::unsafe_arena_release_magnitometer() {
  // @@protoc_insertion_point(field_release:AMUR.AmurSensors.magnitometer)
  
  ::AMUR::AmurSensors_Magnitometer* temp = magnitometer_;
  magnitometer_ = nullptr;
  return temp;
}
inline ::AMUR::AmurSensors_Magnitometer* AmurSensors::_internal_mutable_magnitometer() {
  
  if (magnitometer_ == nullptr) {
    auto* p = CreateMaybeMessage<::AMUR::AmurSensors_Magnitometer>(GetArena());
    magnitometer_ = p;
  }
  return magnitometer_;
}
inline ::AMUR::AmurSensors_Magnitometer* AmurSensors::mutable_magnitometer() {
  // @@protoc_insertion_point(field_mutable:AMUR.AmurSensors.magnitometer)
  return _internal_mutable_magnitometer();
}
inline void AmurSensors::set_allocated_magnitometer(::AMUR::AmurSensors_Magnitometer* magnitometer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete magnitometer_;
  }
  if (magnitometer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(magnitometer);
    if (message_arena != submessage_arena) {
      magnitometer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, magnitometer, submessage_arena);
    }
    
  } else {
    
  }
  magnitometer_ = magnitometer;
  // @@protoc_insertion_point(field_set_allocated:AMUR.AmurSensors.magnitometer)
}

// .AMUR.AmurSensors.WheelEncoders wheelEncoders = 4;
inline bool AmurSensors::_internal_has_wheelencoders() const {
  return this != internal_default_instance() && wheelencoders_ != nullptr;
}
inline bool AmurSensors::has_wheelencoders() const {
  return _internal_has_wheelencoders();
}
inline void AmurSensors::clear_wheelencoders() {
  if (GetArena() == nullptr && wheelencoders_ != nullptr) {
    delete wheelencoders_;
  }
  wheelencoders_ = nullptr;
}
inline const ::AMUR::AmurSensors_WheelEncoders& AmurSensors::_internal_wheelencoders() const {
  const ::AMUR::AmurSensors_WheelEncoders* p = wheelencoders_;
  return p != nullptr ? *p : *reinterpret_cast<const ::AMUR::AmurSensors_WheelEncoders*>(
      &::AMUR::_AmurSensors_WheelEncoders_default_instance_);
}
inline const ::AMUR::AmurSensors_WheelEncoders& AmurSensors::wheelencoders() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.wheelEncoders)
  return _internal_wheelencoders();
}
inline void AmurSensors::unsafe_arena_set_allocated_wheelencoders(
    ::AMUR::AmurSensors_WheelEncoders* wheelencoders) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wheelencoders_);
  }
  wheelencoders_ = wheelencoders;
  if (wheelencoders) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AMUR.AmurSensors.wheelEncoders)
}
inline ::AMUR::AmurSensors_WheelEncoders* AmurSensors::release_wheelencoders() {
  auto temp = unsafe_arena_release_wheelencoders();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::AMUR::AmurSensors_WheelEncoders* AmurSensors::unsafe_arena_release_wheelencoders() {
  // @@protoc_insertion_point(field_release:AMUR.AmurSensors.wheelEncoders)
  
  ::AMUR::AmurSensors_WheelEncoders* temp = wheelencoders_;
  wheelencoders_ = nullptr;
  return temp;
}
inline ::AMUR::AmurSensors_WheelEncoders* AmurSensors::_internal_mutable_wheelencoders() {
  
  if (wheelencoders_ == nullptr) {
    auto* p = CreateMaybeMessage<::AMUR::AmurSensors_WheelEncoders>(GetArena());
    wheelencoders_ = p;
  }
  return wheelencoders_;
}
inline ::AMUR::AmurSensors_WheelEncoders* AmurSensors::mutable_wheelencoders() {
  // @@protoc_insertion_point(field_mutable:AMUR.AmurSensors.wheelEncoders)
  return _internal_mutable_wheelencoders();
}
inline void AmurSensors::set_allocated_wheelencoders(::AMUR::AmurSensors_WheelEncoders* wheelencoders) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete wheelencoders_;
  }
  if (wheelencoders) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(wheelencoders);
    if (message_arena != submessage_arena) {
      wheelencoders = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wheelencoders, submessage_arena);
    }
    
  } else {
    
  }
  wheelencoders_ = wheelencoders;
  // @@protoc_insertion_point(field_set_allocated:AMUR.AmurSensors.wheelEncoders)
}

// .AMUR.AmurSensors.HandEncoders handEncoders = 5;
inline bool AmurSensors::_internal_has_handencoders() const {
  return this != internal_default_instance() && handencoders_ != nullptr;
}
inline bool AmurSensors::has_handencoders() const {
  return _internal_has_handencoders();
}
inline void AmurSensors::clear_handencoders() {
  if (GetArena() == nullptr && handencoders_ != nullptr) {
    delete handencoders_;
  }
  handencoders_ = nullptr;
}
inline const ::AMUR::AmurSensors_HandEncoders& AmurSensors::_internal_handencoders() const {
  const ::AMUR::AmurSensors_HandEncoders* p = handencoders_;
  return p != nullptr ? *p : *reinterpret_cast<const ::AMUR::AmurSensors_HandEncoders*>(
      &::AMUR::_AmurSensors_HandEncoders_default_instance_);
}
inline const ::AMUR::AmurSensors_HandEncoders& AmurSensors::handencoders() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.handEncoders)
  return _internal_handencoders();
}
inline void AmurSensors::unsafe_arena_set_allocated_handencoders(
    ::AMUR::AmurSensors_HandEncoders* handencoders) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handencoders_);
  }
  handencoders_ = handencoders;
  if (handencoders) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AMUR.AmurSensors.handEncoders)
}
inline ::AMUR::AmurSensors_HandEncoders* AmurSensors::release_handencoders() {
  auto temp = unsafe_arena_release_handencoders();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::AMUR::AmurSensors_HandEncoders* AmurSensors::unsafe_arena_release_handencoders() {
  // @@protoc_insertion_point(field_release:AMUR.AmurSensors.handEncoders)
  
  ::AMUR::AmurSensors_HandEncoders* temp = handencoders_;
  handencoders_ = nullptr;
  return temp;
}
inline ::AMUR::AmurSensors_HandEncoders* AmurSensors::_internal_mutable_handencoders() {
  
  if (handencoders_ == nullptr) {
    auto* p = CreateMaybeMessage<::AMUR::AmurSensors_HandEncoders>(GetArena());
    handencoders_ = p;
  }
  return handencoders_;
}
inline ::AMUR::AmurSensors_HandEncoders* AmurSensors::mutable_handencoders() {
  // @@protoc_insertion_point(field_mutable:AMUR.AmurSensors.handEncoders)
  return _internal_mutable_handencoders();
}
inline void AmurSensors::set_allocated_handencoders(::AMUR::AmurSensors_HandEncoders* handencoders) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete handencoders_;
  }
  if (handencoders) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(handencoders);
    if (message_arena != submessage_arena) {
      handencoders = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handencoders, submessage_arena);
    }
    
  } else {
    
  }
  handencoders_ = handencoders;
  // @@protoc_insertion_point(field_set_allocated:AMUR.AmurSensors.handEncoders)
}

// .AMUR.AmurSensors.Temperature temperature = 6;
inline bool AmurSensors::_internal_has_temperature() const {
  return this != internal_default_instance() && temperature_ != nullptr;
}
inline bool AmurSensors::has_temperature() const {
  return _internal_has_temperature();
}
inline void AmurSensors::clear_temperature() {
  if (GetArena() == nullptr && temperature_ != nullptr) {
    delete temperature_;
  }
  temperature_ = nullptr;
}
inline const ::AMUR::AmurSensors_Temperature& AmurSensors::_internal_temperature() const {
  const ::AMUR::AmurSensors_Temperature* p = temperature_;
  return p != nullptr ? *p : *reinterpret_cast<const ::AMUR::AmurSensors_Temperature*>(
      &::AMUR::_AmurSensors_Temperature_default_instance_);
}
inline const ::AMUR::AmurSensors_Temperature& AmurSensors::temperature() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.temperature)
  return _internal_temperature();
}
inline void AmurSensors::unsafe_arena_set_allocated_temperature(
    ::AMUR::AmurSensors_Temperature* temperature) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temperature_);
  }
  temperature_ = temperature;
  if (temperature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AMUR.AmurSensors.temperature)
}
inline ::AMUR::AmurSensors_Temperature* AmurSensors::release_temperature() {
  auto temp = unsafe_arena_release_temperature();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::AMUR::AmurSensors_Temperature* AmurSensors::unsafe_arena_release_temperature() {
  // @@protoc_insertion_point(field_release:AMUR.AmurSensors.temperature)
  
  ::AMUR::AmurSensors_Temperature* temp = temperature_;
  temperature_ = nullptr;
  return temp;
}
inline ::AMUR::AmurSensors_Temperature* AmurSensors::_internal_mutable_temperature() {
  
  if (temperature_ == nullptr) {
    auto* p = CreateMaybeMessage<::AMUR::AmurSensors_Temperature>(GetArena());
    temperature_ = p;
  }
  return temperature_;
}
inline ::AMUR::AmurSensors_Temperature* AmurSensors::mutable_temperature() {
  // @@protoc_insertion_point(field_mutable:AMUR.AmurSensors.temperature)
  return _internal_mutable_temperature();
}
inline void AmurSensors::set_allocated_temperature(::AMUR::AmurSensors_Temperature* temperature) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete temperature_;
  }
  if (temperature) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(temperature);
    if (message_arena != submessage_arena) {
      temperature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, temperature, submessage_arena);
    }
    
  } else {
    
  }
  temperature_ = temperature;
  // @@protoc_insertion_point(field_set_allocated:AMUR.AmurSensors.temperature)
}

// .AMUR.AmurSensors.Misc misc = 7;
inline bool AmurSensors::_internal_has_misc() const {
  return this != internal_default_instance() && misc_ != nullptr;
}
inline bool AmurSensors::has_misc() const {
  return _internal_has_misc();
}
inline void AmurSensors::clear_misc() {
  if (GetArena() == nullptr && misc_ != nullptr) {
    delete misc_;
  }
  misc_ = nullptr;
}
inline const ::AMUR::AmurSensors_Misc& AmurSensors::_internal_misc() const {
  const ::AMUR::AmurSensors_Misc* p = misc_;
  return p != nullptr ? *p : *reinterpret_cast<const ::AMUR::AmurSensors_Misc*>(
      &::AMUR::_AmurSensors_Misc_default_instance_);
}
inline const ::AMUR::AmurSensors_Misc& AmurSensors::misc() const {
  // @@protoc_insertion_point(field_get:AMUR.AmurSensors.misc)
  return _internal_misc();
}
inline void AmurSensors::unsafe_arena_set_allocated_misc(
    ::AMUR::AmurSensors_Misc* misc) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(misc_);
  }
  misc_ = misc;
  if (misc) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AMUR.AmurSensors.misc)
}
inline ::AMUR::AmurSensors_Misc* AmurSensors::release_misc() {
  auto temp = unsafe_arena_release_misc();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::AMUR::AmurSensors_Misc* AmurSensors::unsafe_arena_release_misc() {
  // @@protoc_insertion_point(field_release:AMUR.AmurSensors.misc)
  
  ::AMUR::AmurSensors_Misc* temp = misc_;
  misc_ = nullptr;
  return temp;
}
inline ::AMUR::AmurSensors_Misc* AmurSensors::_internal_mutable_misc() {
  
  if (misc_ == nullptr) {
    auto* p = CreateMaybeMessage<::AMUR::AmurSensors_Misc>(GetArena());
    misc_ = p;
  }
  return misc_;
}
inline ::AMUR::AmurSensors_Misc* AmurSensors::mutable_misc() {
  // @@protoc_insertion_point(field_mutable:AMUR.AmurSensors.misc)
  return _internal_mutable_misc();
}
inline void AmurSensors::set_allocated_misc(::AMUR::AmurSensors_Misc* misc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete misc_;
  }
  if (misc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(misc);
    if (message_arena != submessage_arena) {
      misc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, misc, submessage_arena);
    }
    
  } else {
    
  }
  misc_ = misc;
  // @@protoc_insertion_point(field_set_allocated:AMUR.AmurSensors.misc)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace AMUR

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_amur_2eproto
