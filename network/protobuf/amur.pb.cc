// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: amur.proto

#include "amur.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_amur_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurControls_CameraServos_amur_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_amur_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurControls_HandMotors_amur_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_amur_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurControls_Light_amur_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_amur_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurControls_System_amur_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_amur_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurControls_WheelMotors_amur_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_amur_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurSensors_Accelerometer_amur_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_amur_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurSensors_Gyroscope_amur_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_amur_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurSensors_HandEncoders_amur_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_amur_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurSensors_Magnitometer_amur_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_amur_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurSensors_Misc_amur_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_amur_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurSensors_Temperature_amur_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_amur_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurSensors_WheelEncoders_amur_2eproto;
namespace AMUR {
class AmurControls_CameraServosDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AmurControls_CameraServos> _instance;
} _AmurControls_CameraServos_default_instance_;
class AmurControls_WheelMotorsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AmurControls_WheelMotors> _instance;
} _AmurControls_WheelMotors_default_instance_;
class AmurControls_HandMotorsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AmurControls_HandMotors> _instance;
} _AmurControls_HandMotors_default_instance_;
class AmurControls_LightDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AmurControls_Light> _instance;
} _AmurControls_Light_default_instance_;
class AmurControls_SystemDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AmurControls_System> _instance;
} _AmurControls_System_default_instance_;
class AmurControlsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AmurControls> _instance;
} _AmurControls_default_instance_;
class AmurSensors_AccelerometerDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AmurSensors_Accelerometer> _instance;
} _AmurSensors_Accelerometer_default_instance_;
class AmurSensors_GyroscopeDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AmurSensors_Gyroscope> _instance;
} _AmurSensors_Gyroscope_default_instance_;
class AmurSensors_MagnitometerDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AmurSensors_Magnitometer> _instance;
} _AmurSensors_Magnitometer_default_instance_;
class AmurSensors_WheelEncodersDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AmurSensors_WheelEncoders> _instance;
} _AmurSensors_WheelEncoders_default_instance_;
class AmurSensors_HandEncodersDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AmurSensors_HandEncoders> _instance;
} _AmurSensors_HandEncoders_default_instance_;
class AmurSensors_TemperatureDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AmurSensors_Temperature> _instance;
} _AmurSensors_Temperature_default_instance_;
class AmurSensors_WheelCurrentDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AmurSensors_WheelCurrent> _instance;
} _AmurSensors_WheelCurrent_default_instance_;
class AmurSensors_HandCurrentDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AmurSensors_HandCurrent> _instance;
} _AmurSensors_HandCurrent_default_instance_;
class AmurSensors_MiscDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AmurSensors_Misc> _instance;
} _AmurSensors_Misc_default_instance_;
class AmurSensorsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AmurSensors> _instance;
} _AmurSensors_default_instance_;
}  // namespace AMUR
static void InitDefaultsscc_info_AmurControls_amur_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::AMUR::_AmurControls_default_instance_;
    new (ptr) ::AMUR::AmurControls();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::AMUR::AmurControls::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<5> scc_info_AmurControls_amur_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 5, 0, InitDefaultsscc_info_AmurControls_amur_2eproto}, {
      &scc_info_AmurControls_CameraServos_amur_2eproto.base,
      &scc_info_AmurControls_WheelMotors_amur_2eproto.base,
      &scc_info_AmurControls_HandMotors_amur_2eproto.base,
      &scc_info_AmurControls_Light_amur_2eproto.base,
      &scc_info_AmurControls_System_amur_2eproto.base,}};

static void InitDefaultsscc_info_AmurControls_CameraServos_amur_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::AMUR::_AmurControls_CameraServos_default_instance_;
    new (ptr) ::AMUR::AmurControls_CameraServos();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::AMUR::AmurControls_CameraServos::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurControls_CameraServos_amur_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_AmurControls_CameraServos_amur_2eproto}, {}};

static void InitDefaultsscc_info_AmurControls_HandMotors_amur_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::AMUR::_AmurControls_HandMotors_default_instance_;
    new (ptr) ::AMUR::AmurControls_HandMotors();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::AMUR::AmurControls_HandMotors::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurControls_HandMotors_amur_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_AmurControls_HandMotors_amur_2eproto}, {}};

static void InitDefaultsscc_info_AmurControls_Light_amur_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::AMUR::_AmurControls_Light_default_instance_;
    new (ptr) ::AMUR::AmurControls_Light();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::AMUR::AmurControls_Light::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurControls_Light_amur_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_AmurControls_Light_amur_2eproto}, {}};

static void InitDefaultsscc_info_AmurControls_System_amur_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::AMUR::_AmurControls_System_default_instance_;
    new (ptr) ::AMUR::AmurControls_System();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::AMUR::AmurControls_System::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurControls_System_amur_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_AmurControls_System_amur_2eproto}, {}};

static void InitDefaultsscc_info_AmurControls_WheelMotors_amur_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::AMUR::_AmurControls_WheelMotors_default_instance_;
    new (ptr) ::AMUR::AmurControls_WheelMotors();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::AMUR::AmurControls_WheelMotors::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurControls_WheelMotors_amur_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_AmurControls_WheelMotors_amur_2eproto}, {}};

static void InitDefaultsscc_info_AmurSensors_amur_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::AMUR::_AmurSensors_default_instance_;
    new (ptr) ::AMUR::AmurSensors();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::AMUR::AmurSensors::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<7> scc_info_AmurSensors_amur_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 7, 0, InitDefaultsscc_info_AmurSensors_amur_2eproto}, {
      &scc_info_AmurSensors_Accelerometer_amur_2eproto.base,
      &scc_info_AmurSensors_Gyroscope_amur_2eproto.base,
      &scc_info_AmurSensors_Magnitometer_amur_2eproto.base,
      &scc_info_AmurSensors_WheelEncoders_amur_2eproto.base,
      &scc_info_AmurSensors_HandEncoders_amur_2eproto.base,
      &scc_info_AmurSensors_Temperature_amur_2eproto.base,
      &scc_info_AmurSensors_Misc_amur_2eproto.base,}};

static void InitDefaultsscc_info_AmurSensors_Accelerometer_amur_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::AMUR::_AmurSensors_Accelerometer_default_instance_;
    new (ptr) ::AMUR::AmurSensors_Accelerometer();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::AMUR::AmurSensors_Accelerometer::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurSensors_Accelerometer_amur_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_AmurSensors_Accelerometer_amur_2eproto}, {}};

static void InitDefaultsscc_info_AmurSensors_Gyroscope_amur_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::AMUR::_AmurSensors_Gyroscope_default_instance_;
    new (ptr) ::AMUR::AmurSensors_Gyroscope();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::AMUR::AmurSensors_Gyroscope::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurSensors_Gyroscope_amur_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_AmurSensors_Gyroscope_amur_2eproto}, {}};

static void InitDefaultsscc_info_AmurSensors_HandCurrent_amur_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::AMUR::_AmurSensors_HandCurrent_default_instance_;
    new (ptr) ::AMUR::AmurSensors_HandCurrent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::AMUR::AmurSensors_HandCurrent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurSensors_HandCurrent_amur_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_AmurSensors_HandCurrent_amur_2eproto}, {}};

static void InitDefaultsscc_info_AmurSensors_HandEncoders_amur_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::AMUR::_AmurSensors_HandEncoders_default_instance_;
    new (ptr) ::AMUR::AmurSensors_HandEncoders();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::AMUR::AmurSensors_HandEncoders::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurSensors_HandEncoders_amur_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_AmurSensors_HandEncoders_amur_2eproto}, {}};

static void InitDefaultsscc_info_AmurSensors_Magnitometer_amur_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::AMUR::_AmurSensors_Magnitometer_default_instance_;
    new (ptr) ::AMUR::AmurSensors_Magnitometer();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::AMUR::AmurSensors_Magnitometer::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurSensors_Magnitometer_amur_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_AmurSensors_Magnitometer_amur_2eproto}, {}};

static void InitDefaultsscc_info_AmurSensors_Misc_amur_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::AMUR::_AmurSensors_Misc_default_instance_;
    new (ptr) ::AMUR::AmurSensors_Misc();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::AMUR::AmurSensors_Misc::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurSensors_Misc_amur_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_AmurSensors_Misc_amur_2eproto}, {}};

static void InitDefaultsscc_info_AmurSensors_Temperature_amur_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::AMUR::_AmurSensors_Temperature_default_instance_;
    new (ptr) ::AMUR::AmurSensors_Temperature();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::AMUR::AmurSensors_Temperature::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurSensors_Temperature_amur_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_AmurSensors_Temperature_amur_2eproto}, {}};

static void InitDefaultsscc_info_AmurSensors_WheelCurrent_amur_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::AMUR::_AmurSensors_WheelCurrent_default_instance_;
    new (ptr) ::AMUR::AmurSensors_WheelCurrent();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::AMUR::AmurSensors_WheelCurrent::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurSensors_WheelCurrent_amur_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_AmurSensors_WheelCurrent_amur_2eproto}, {}};

static void InitDefaultsscc_info_AmurSensors_WheelEncoders_amur_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::AMUR::_AmurSensors_WheelEncoders_default_instance_;
    new (ptr) ::AMUR::AmurSensors_WheelEncoders();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::AMUR::AmurSensors_WheelEncoders::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurSensors_WheelEncoders_amur_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_AmurSensors_WheelEncoders_amur_2eproto}, {}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_amur_2eproto[16];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_amur_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_amur_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_amur_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurControls_CameraServos, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurControls_CameraServos, xangle_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurControls_CameraServos, yangle_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurControls_WheelMotors, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurControls_WheelMotors, leftpower_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurControls_WheelMotors, lefttime_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurControls_WheelMotors, rightpower_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurControls_WheelMotors, righttime_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurControls_HandMotors, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurControls_HandMotors, leftpower_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurControls_HandMotors, lefttime_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurControls_HandMotors, rightpower_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurControls_HandMotors, righttime_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurControls_HandMotors, leftrelay_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurControls_HandMotors, rightrelay_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurControls_Light, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurControls_Light, ledleftpower_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurControls_Light, ledrightpower_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurControls_System, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurControls_System, haltflag_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurControls_System, restartflag_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurControls_System, timeonamur_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurControls, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurControls, cameraservos_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurControls, wheelmotors_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurControls, handmotors_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurControls, light_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurControls, system_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_Accelerometer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_Accelerometer, x_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_Accelerometer, y_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_Accelerometer, z_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_Gyroscope, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_Gyroscope, x_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_Gyroscope, y_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_Gyroscope, z_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_Magnitometer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_Magnitometer, x_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_Magnitometer, y_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_Magnitometer, z_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_WheelEncoders, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_WheelEncoders, leftangle_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_WheelEncoders, rightangle_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_HandEncoders, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_HandEncoders, leftinternalangle_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_HandEncoders, rightinternalangle_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_HandEncoders, leftouterangle_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_HandEncoders, rightouterangle_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_Temperature, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_Temperature, tempaccelerometer_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_Temperature, tempcpu_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_Temperature, temppressure_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_WheelCurrent, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_WheelCurrent, leftcurrent_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_WheelCurrent, rightcurrent_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_HandCurrent, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_HandCurrent, leftcurrent_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_HandCurrent, rightcurrent_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_Misc, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_Misc, gas_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_Misc, batteryvoltage_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_Misc, raspberryvoltage_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors_Misc, pressure_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors, accelerometer_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors, gyroscope_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors, magnitometer_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors, wheelencoders_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors, handencoders_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors, temperature_),
  PROTOBUF_FIELD_OFFSET(::AMUR::AmurSensors, misc_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, sizeof(::AMUR::AmurControls_CameraServos)},
  { 7, -1, sizeof(::AMUR::AmurControls_WheelMotors)},
  { 16, -1, sizeof(::AMUR::AmurControls_HandMotors)},
  { 27, -1, sizeof(::AMUR::AmurControls_Light)},
  { 34, -1, sizeof(::AMUR::AmurControls_System)},
  { 42, -1, sizeof(::AMUR::AmurControls)},
  { 52, -1, sizeof(::AMUR::AmurSensors_Accelerometer)},
  { 60, -1, sizeof(::AMUR::AmurSensors_Gyroscope)},
  { 68, -1, sizeof(::AMUR::AmurSensors_Magnitometer)},
  { 76, -1, sizeof(::AMUR::AmurSensors_WheelEncoders)},
  { 83, -1, sizeof(::AMUR::AmurSensors_HandEncoders)},
  { 92, -1, sizeof(::AMUR::AmurSensors_Temperature)},
  { 100, -1, sizeof(::AMUR::AmurSensors_WheelCurrent)},
  { 107, -1, sizeof(::AMUR::AmurSensors_HandCurrent)},
  { 114, -1, sizeof(::AMUR::AmurSensors_Misc)},
  { 123, -1, sizeof(::AMUR::AmurSensors)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::AMUR::_AmurControls_CameraServos_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::AMUR::_AmurControls_WheelMotors_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::AMUR::_AmurControls_HandMotors_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::AMUR::_AmurControls_Light_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::AMUR::_AmurControls_System_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::AMUR::_AmurControls_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::AMUR::_AmurSensors_Accelerometer_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::AMUR::_AmurSensors_Gyroscope_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::AMUR::_AmurSensors_Magnitometer_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::AMUR::_AmurSensors_WheelEncoders_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::AMUR::_AmurSensors_HandEncoders_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::AMUR::_AmurSensors_Temperature_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::AMUR::_AmurSensors_WheelCurrent_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::AMUR::_AmurSensors_HandCurrent_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::AMUR::_AmurSensors_Misc_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::AMUR::_AmurSensors_default_instance_),
};

const char descriptor_table_protodef_amur_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\namur.proto\022\004AMUR\"\210\005\n\014AmurControls\0225\n\014c"
  "ameraServos\030\001 \001(\0132\037.AMUR.AmurControls.Ca"
  "meraServos\0223\n\013wheelMotors\030\002 \001(\0132\036.AMUR.A"
  "murControls.WheelMotors\0221\n\nhandMotors\030\003 "
  "\001(\0132\035.AMUR.AmurControls.HandMotors\022\'\n\005li"
  "ght\030\004 \001(\0132\030.AMUR.AmurControls.Light\022)\n\006s"
  "ystem\030\005 \001(\0132\031.AMUR.AmurControls.System\032."
  "\n\014CameraServos\022\016\n\006xAngle\030\001 \001(\005\022\016\n\006yAngle"
  "\030\002 \001(\005\032Y\n\013WheelMotors\022\021\n\tleftPower\030\001 \001(\005"
  "\022\020\n\010leftTime\030\002 \001(\r\022\022\n\nrightPower\030\003 \001(\005\022\021"
  "\n\trightTime\030\004 \001(\r\032\177\n\nHandMotors\022\021\n\tleftP"
  "ower\030\001 \001(\005\022\020\n\010leftTime\030\002 \001(\r\022\022\n\nrightPow"
  "er\030\003 \001(\005\022\021\n\trightTime\030\004 \001(\r\022\021\n\tleftRelay"
  "\030\005 \001(\010\022\022\n\nrightRelay\030\006 \001(\010\0324\n\005Light\022\024\n\014l"
  "edLeftPower\030\001 \001(\r\022\025\n\rledRightPower\030\002 \001(\r"
  "\032C\n\006System\022\020\n\010haltFlag\030\001 \001(\010\022\023\n\013restartF"
  "lag\030\002 \001(\010\022\022\n\ntimeOnAmur\030\003 \001(\t\"\323\007\n\013AmurSe"
  "nsors\0226\n\raccelerometer\030\001 \001(\0132\037.AMUR.Amur"
  "Sensors.Accelerometer\022.\n\tgyroscope\030\002 \001(\013"
  "2\033.AMUR.AmurSensors.Gyroscope\0224\n\014magnito"
  "meter\030\003 \001(\0132\036.AMUR.AmurSensors.Magnitome"
  "ter\0226\n\rwheelEncoders\030\004 \001(\0132\037.AMUR.AmurSe"
  "nsors.WheelEncoders\0224\n\014handEncoders\030\005 \001("
  "\0132\036.AMUR.AmurSensors.HandEncoders\0222\n\013tem"
  "perature\030\006 \001(\0132\035.AMUR.AmurSensors.Temper"
  "ature\022$\n\004misc\030\007 \001(\0132\026.AMUR.AmurSensors.M"
  "isc\0320\n\rAccelerometer\022\t\n\001x\030\001 \001(\002\022\t\n\001y\030\002 \001"
  "(\002\022\t\n\001z\030\003 \001(\002\032,\n\tGyroscope\022\t\n\001x\030\001 \001(\002\022\t\n"
  "\001y\030\002 \001(\002\022\t\n\001z\030\003 \001(\002\032/\n\014Magnitometer\022\t\n\001x"
  "\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\022\t\n\001z\030\003 \001(\002\0326\n\rWheelEnc"
  "oders\022\021\n\tleftAngle\030\001 \001(\005\022\022\n\nrightAngle\030\002"
  " \001(\005\032v\n\014HandEncoders\022\031\n\021leftInternalAngl"
  "e\030\001 \001(\005\022\032\n\022rightInternalAngle\030\002 \001(\005\022\026\n\016l"
  "eftOuterAngle\030\003 \001(\005\022\027\n\017rightOuterAngle\030\004"
  " \001(\005\032O\n\013Temperature\022\031\n\021tempAccelerometer"
  "\030\001 \001(\005\022\017\n\007tempCPU\030\002 \001(\005\022\024\n\014tempPressure\030"
  "\003 \001(\005\0329\n\014WheelCurrent\022\023\n\013leftCurrent\030\001 \001"
  "(\r\022\024\n\014rightCurrent\030\002 \001(\r\0328\n\013HandCurrent\022"
  "\023\n\013leftCurrent\030\001 \001(\r\022\024\n\014rightCurrent\030\002 \001"
  "(\r\032W\n\004Misc\022\013\n\003gas\030\001 \001(\005\022\026\n\016batteryVoltag"
  "e\030\002 \001(\005\022\030\n\020raspberryVoltage\030\003 \001(\005\022\020\n\010pre"
  "ssure\030\004 \001(\0022\205\001\n\013Maintenance\0225\n\014DataExcha"
  "nge\022\021.AMUR.AmurSensors\032\022.AMUR.AmurContro"
  "ls\022\?\n\022DataStreamExchange\022\021.AMUR.AmurSens"
  "ors\032\022.AMUR.AmurControls(\0010\001B)\n\023info.sens"
  "orika.amurB\tAmurProtoP\001\242\002\004AMURb\006proto3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_amur_2eproto_deps[1] = {
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_amur_2eproto_sccs[16] = {
  &scc_info_AmurControls_amur_2eproto.base,
  &scc_info_AmurControls_CameraServos_amur_2eproto.base,
  &scc_info_AmurControls_HandMotors_amur_2eproto.base,
  &scc_info_AmurControls_Light_amur_2eproto.base,
  &scc_info_AmurControls_System_amur_2eproto.base,
  &scc_info_AmurControls_WheelMotors_amur_2eproto.base,
  &scc_info_AmurSensors_amur_2eproto.base,
  &scc_info_AmurSensors_Accelerometer_amur_2eproto.base,
  &scc_info_AmurSensors_Gyroscope_amur_2eproto.base,
  &scc_info_AmurSensors_HandCurrent_amur_2eproto.base,
  &scc_info_AmurSensors_HandEncoders_amur_2eproto.base,
  &scc_info_AmurSensors_Magnitometer_amur_2eproto.base,
  &scc_info_AmurSensors_Misc_amur_2eproto.base,
  &scc_info_AmurSensors_Temperature_amur_2eproto.base,
  &scc_info_AmurSensors_WheelCurrent_amur_2eproto.base,
  &scc_info_AmurSensors_WheelEncoders_amur_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_amur_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_amur_2eproto = {
  false, false, descriptor_table_protodef_amur_2eproto, "amur.proto", 1838,
  &descriptor_table_amur_2eproto_once, descriptor_table_amur_2eproto_sccs, descriptor_table_amur_2eproto_deps, 16, 0,
  schemas, file_default_instances, TableStruct_amur_2eproto::offsets,
  file_level_metadata_amur_2eproto, 16, file_level_enum_descriptors_amur_2eproto, file_level_service_descriptors_amur_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_amur_2eproto = (static_cast<void>(::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_amur_2eproto)), true);
namespace AMUR {

// ===================================================================

void AmurControls_CameraServos::InitAsDefaultInstance() {
}
class AmurControls_CameraServos::_Internal {
 public:
};

AmurControls_CameraServos::AmurControls_CameraServos(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:AMUR.AmurControls.CameraServos)
}
AmurControls_CameraServos::AmurControls_CameraServos(const AmurControls_CameraServos& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&xangle_, &from.xangle_,
    static_cast<size_t>(reinterpret_cast<char*>(&yangle_) -
    reinterpret_cast<char*>(&xangle_)) + sizeof(yangle_));
  // @@protoc_insertion_point(copy_constructor:AMUR.AmurControls.CameraServos)
}

void AmurControls_CameraServos::SharedCtor() {
  ::memset(&xangle_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&yangle_) -
      reinterpret_cast<char*>(&xangle_)) + sizeof(yangle_));
}

AmurControls_CameraServos::~AmurControls_CameraServos() {
  // @@protoc_insertion_point(destructor:AMUR.AmurControls.CameraServos)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void AmurControls_CameraServos::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void AmurControls_CameraServos::ArenaDtor(void* object) {
  AmurControls_CameraServos* _this = reinterpret_cast< AmurControls_CameraServos* >(object);
  (void)_this;
}
void AmurControls_CameraServos::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AmurControls_CameraServos::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AmurControls_CameraServos& AmurControls_CameraServos::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AmurControls_CameraServos_amur_2eproto.base);
  return *internal_default_instance();
}


void AmurControls_CameraServos::Clear() {
// @@protoc_insertion_point(message_clear_start:AMUR.AmurControls.CameraServos)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&xangle_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&yangle_) -
      reinterpret_cast<char*>(&xangle_)) + sizeof(yangle_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AmurControls_CameraServos::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // int32 xAngle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          xangle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 yAngle = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          yangle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AmurControls_CameraServos::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AMUR.AmurControls.CameraServos)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 xAngle = 1;
  if (this->xangle() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_xangle(), target);
  }

  // int32 yAngle = 2;
  if (this->yangle() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_yangle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AMUR.AmurControls.CameraServos)
  return target;
}

size_t AmurControls_CameraServos::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AMUR.AmurControls.CameraServos)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 xAngle = 1;
  if (this->xangle() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_xangle());
  }

  // int32 yAngle = 2;
  if (this->yangle() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_yangle());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AmurControls_CameraServos::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:AMUR.AmurControls.CameraServos)
  GOOGLE_DCHECK_NE(&from, this);
  const AmurControls_CameraServos* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AmurControls_CameraServos>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:AMUR.AmurControls.CameraServos)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:AMUR.AmurControls.CameraServos)
    MergeFrom(*source);
  }
}

void AmurControls_CameraServos::MergeFrom(const AmurControls_CameraServos& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AMUR.AmurControls.CameraServos)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.xangle() != 0) {
    _internal_set_xangle(from._internal_xangle());
  }
  if (from.yangle() != 0) {
    _internal_set_yangle(from._internal_yangle());
  }
}

void AmurControls_CameraServos::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:AMUR.AmurControls.CameraServos)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AmurControls_CameraServos::CopyFrom(const AmurControls_CameraServos& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AMUR.AmurControls.CameraServos)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AmurControls_CameraServos::IsInitialized() const {
  return true;
}

void AmurControls_CameraServos::InternalSwap(AmurControls_CameraServos* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AmurControls_CameraServos, yangle_)
      + sizeof(AmurControls_CameraServos::yangle_)
      - PROTOBUF_FIELD_OFFSET(AmurControls_CameraServos, xangle_)>(
          reinterpret_cast<char*>(&xangle_),
          reinterpret_cast<char*>(&other->xangle_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AmurControls_CameraServos::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AmurControls_WheelMotors::InitAsDefaultInstance() {
}
class AmurControls_WheelMotors::_Internal {
 public:
};

AmurControls_WheelMotors::AmurControls_WheelMotors(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:AMUR.AmurControls.WheelMotors)
}
AmurControls_WheelMotors::AmurControls_WheelMotors(const AmurControls_WheelMotors& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&leftpower_, &from.leftpower_,
    static_cast<size_t>(reinterpret_cast<char*>(&righttime_) -
    reinterpret_cast<char*>(&leftpower_)) + sizeof(righttime_));
  // @@protoc_insertion_point(copy_constructor:AMUR.AmurControls.WheelMotors)
}

void AmurControls_WheelMotors::SharedCtor() {
  ::memset(&leftpower_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&righttime_) -
      reinterpret_cast<char*>(&leftpower_)) + sizeof(righttime_));
}

AmurControls_WheelMotors::~AmurControls_WheelMotors() {
  // @@protoc_insertion_point(destructor:AMUR.AmurControls.WheelMotors)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void AmurControls_WheelMotors::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void AmurControls_WheelMotors::ArenaDtor(void* object) {
  AmurControls_WheelMotors* _this = reinterpret_cast< AmurControls_WheelMotors* >(object);
  (void)_this;
}
void AmurControls_WheelMotors::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AmurControls_WheelMotors::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AmurControls_WheelMotors& AmurControls_WheelMotors::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AmurControls_WheelMotors_amur_2eproto.base);
  return *internal_default_instance();
}


void AmurControls_WheelMotors::Clear() {
// @@protoc_insertion_point(message_clear_start:AMUR.AmurControls.WheelMotors)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&leftpower_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&righttime_) -
      reinterpret_cast<char*>(&leftpower_)) + sizeof(righttime_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AmurControls_WheelMotors::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // int32 leftPower = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          leftpower_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 leftTime = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          lefttime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 rightPower = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          rightpower_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 rightTime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          righttime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AmurControls_WheelMotors::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AMUR.AmurControls.WheelMotors)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 leftPower = 1;
  if (this->leftpower() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_leftpower(), target);
  }

  // uint32 leftTime = 2;
  if (this->lefttime() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_lefttime(), target);
  }

  // int32 rightPower = 3;
  if (this->rightpower() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_rightpower(), target);
  }

  // uint32 rightTime = 4;
  if (this->righttime() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_righttime(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AMUR.AmurControls.WheelMotors)
  return target;
}

size_t AmurControls_WheelMotors::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AMUR.AmurControls.WheelMotors)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 leftPower = 1;
  if (this->leftpower() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_leftpower());
  }

  // uint32 leftTime = 2;
  if (this->lefttime() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_lefttime());
  }

  // int32 rightPower = 3;
  if (this->rightpower() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_rightpower());
  }

  // uint32 rightTime = 4;
  if (this->righttime() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_righttime());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AmurControls_WheelMotors::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:AMUR.AmurControls.WheelMotors)
  GOOGLE_DCHECK_NE(&from, this);
  const AmurControls_WheelMotors* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AmurControls_WheelMotors>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:AMUR.AmurControls.WheelMotors)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:AMUR.AmurControls.WheelMotors)
    MergeFrom(*source);
  }
}

void AmurControls_WheelMotors::MergeFrom(const AmurControls_WheelMotors& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AMUR.AmurControls.WheelMotors)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.leftpower() != 0) {
    _internal_set_leftpower(from._internal_leftpower());
  }
  if (from.lefttime() != 0) {
    _internal_set_lefttime(from._internal_lefttime());
  }
  if (from.rightpower() != 0) {
    _internal_set_rightpower(from._internal_rightpower());
  }
  if (from.righttime() != 0) {
    _internal_set_righttime(from._internal_righttime());
  }
}

void AmurControls_WheelMotors::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:AMUR.AmurControls.WheelMotors)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AmurControls_WheelMotors::CopyFrom(const AmurControls_WheelMotors& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AMUR.AmurControls.WheelMotors)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AmurControls_WheelMotors::IsInitialized() const {
  return true;
}

void AmurControls_WheelMotors::InternalSwap(AmurControls_WheelMotors* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AmurControls_WheelMotors, righttime_)
      + sizeof(AmurControls_WheelMotors::righttime_)
      - PROTOBUF_FIELD_OFFSET(AmurControls_WheelMotors, leftpower_)>(
          reinterpret_cast<char*>(&leftpower_),
          reinterpret_cast<char*>(&other->leftpower_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AmurControls_WheelMotors::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AmurControls_HandMotors::InitAsDefaultInstance() {
}
class AmurControls_HandMotors::_Internal {
 public:
};

AmurControls_HandMotors::AmurControls_HandMotors(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:AMUR.AmurControls.HandMotors)
}
AmurControls_HandMotors::AmurControls_HandMotors(const AmurControls_HandMotors& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&leftpower_, &from.leftpower_,
    static_cast<size_t>(reinterpret_cast<char*>(&rightrelay_) -
    reinterpret_cast<char*>(&leftpower_)) + sizeof(rightrelay_));
  // @@protoc_insertion_point(copy_constructor:AMUR.AmurControls.HandMotors)
}

void AmurControls_HandMotors::SharedCtor() {
  ::memset(&leftpower_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&rightrelay_) -
      reinterpret_cast<char*>(&leftpower_)) + sizeof(rightrelay_));
}

AmurControls_HandMotors::~AmurControls_HandMotors() {
  // @@protoc_insertion_point(destructor:AMUR.AmurControls.HandMotors)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void AmurControls_HandMotors::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void AmurControls_HandMotors::ArenaDtor(void* object) {
  AmurControls_HandMotors* _this = reinterpret_cast< AmurControls_HandMotors* >(object);
  (void)_this;
}
void AmurControls_HandMotors::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AmurControls_HandMotors::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AmurControls_HandMotors& AmurControls_HandMotors::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AmurControls_HandMotors_amur_2eproto.base);
  return *internal_default_instance();
}


void AmurControls_HandMotors::Clear() {
// @@protoc_insertion_point(message_clear_start:AMUR.AmurControls.HandMotors)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&leftpower_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&rightrelay_) -
      reinterpret_cast<char*>(&leftpower_)) + sizeof(rightrelay_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AmurControls_HandMotors::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // int32 leftPower = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          leftpower_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 leftTime = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          lefttime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 rightPower = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          rightpower_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 rightTime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          righttime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool leftRelay = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          leftrelay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool rightRelay = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          rightrelay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AmurControls_HandMotors::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AMUR.AmurControls.HandMotors)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 leftPower = 1;
  if (this->leftpower() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_leftpower(), target);
  }

  // uint32 leftTime = 2;
  if (this->lefttime() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_lefttime(), target);
  }

  // int32 rightPower = 3;
  if (this->rightpower() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_rightpower(), target);
  }

  // uint32 rightTime = 4;
  if (this->righttime() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_righttime(), target);
  }

  // bool leftRelay = 5;
  if (this->leftrelay() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_leftrelay(), target);
  }

  // bool rightRelay = 6;
  if (this->rightrelay() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_rightrelay(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AMUR.AmurControls.HandMotors)
  return target;
}

size_t AmurControls_HandMotors::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AMUR.AmurControls.HandMotors)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 leftPower = 1;
  if (this->leftpower() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_leftpower());
  }

  // uint32 leftTime = 2;
  if (this->lefttime() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_lefttime());
  }

  // int32 rightPower = 3;
  if (this->rightpower() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_rightpower());
  }

  // uint32 rightTime = 4;
  if (this->righttime() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_righttime());
  }

  // bool leftRelay = 5;
  if (this->leftrelay() != 0) {
    total_size += 1 + 1;
  }

  // bool rightRelay = 6;
  if (this->rightrelay() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AmurControls_HandMotors::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:AMUR.AmurControls.HandMotors)
  GOOGLE_DCHECK_NE(&from, this);
  const AmurControls_HandMotors* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AmurControls_HandMotors>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:AMUR.AmurControls.HandMotors)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:AMUR.AmurControls.HandMotors)
    MergeFrom(*source);
  }
}

void AmurControls_HandMotors::MergeFrom(const AmurControls_HandMotors& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AMUR.AmurControls.HandMotors)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.leftpower() != 0) {
    _internal_set_leftpower(from._internal_leftpower());
  }
  if (from.lefttime() != 0) {
    _internal_set_lefttime(from._internal_lefttime());
  }
  if (from.rightpower() != 0) {
    _internal_set_rightpower(from._internal_rightpower());
  }
  if (from.righttime() != 0) {
    _internal_set_righttime(from._internal_righttime());
  }
  if (from.leftrelay() != 0) {
    _internal_set_leftrelay(from._internal_leftrelay());
  }
  if (from.rightrelay() != 0) {
    _internal_set_rightrelay(from._internal_rightrelay());
  }
}

void AmurControls_HandMotors::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:AMUR.AmurControls.HandMotors)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AmurControls_HandMotors::CopyFrom(const AmurControls_HandMotors& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AMUR.AmurControls.HandMotors)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AmurControls_HandMotors::IsInitialized() const {
  return true;
}

void AmurControls_HandMotors::InternalSwap(AmurControls_HandMotors* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AmurControls_HandMotors, rightrelay_)
      + sizeof(AmurControls_HandMotors::rightrelay_)
      - PROTOBUF_FIELD_OFFSET(AmurControls_HandMotors, leftpower_)>(
          reinterpret_cast<char*>(&leftpower_),
          reinterpret_cast<char*>(&other->leftpower_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AmurControls_HandMotors::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AmurControls_Light::InitAsDefaultInstance() {
}
class AmurControls_Light::_Internal {
 public:
};

AmurControls_Light::AmurControls_Light(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:AMUR.AmurControls.Light)
}
AmurControls_Light::AmurControls_Light(const AmurControls_Light& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&ledleftpower_, &from.ledleftpower_,
    static_cast<size_t>(reinterpret_cast<char*>(&ledrightpower_) -
    reinterpret_cast<char*>(&ledleftpower_)) + sizeof(ledrightpower_));
  // @@protoc_insertion_point(copy_constructor:AMUR.AmurControls.Light)
}

void AmurControls_Light::SharedCtor() {
  ::memset(&ledleftpower_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ledrightpower_) -
      reinterpret_cast<char*>(&ledleftpower_)) + sizeof(ledrightpower_));
}

AmurControls_Light::~AmurControls_Light() {
  // @@protoc_insertion_point(destructor:AMUR.AmurControls.Light)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void AmurControls_Light::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void AmurControls_Light::ArenaDtor(void* object) {
  AmurControls_Light* _this = reinterpret_cast< AmurControls_Light* >(object);
  (void)_this;
}
void AmurControls_Light::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AmurControls_Light::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AmurControls_Light& AmurControls_Light::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AmurControls_Light_amur_2eproto.base);
  return *internal_default_instance();
}


void AmurControls_Light::Clear() {
// @@protoc_insertion_point(message_clear_start:AMUR.AmurControls.Light)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&ledleftpower_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ledrightpower_) -
      reinterpret_cast<char*>(&ledleftpower_)) + sizeof(ledrightpower_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AmurControls_Light::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // uint32 ledLeftPower = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ledleftpower_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 ledRightPower = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ledrightpower_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AmurControls_Light::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AMUR.AmurControls.Light)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 ledLeftPower = 1;
  if (this->ledleftpower() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ledleftpower(), target);
  }

  // uint32 ledRightPower = 2;
  if (this->ledrightpower() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ledrightpower(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AMUR.AmurControls.Light)
  return target;
}

size_t AmurControls_Light::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AMUR.AmurControls.Light)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 ledLeftPower = 1;
  if (this->ledleftpower() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_ledleftpower());
  }

  // uint32 ledRightPower = 2;
  if (this->ledrightpower() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_ledrightpower());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AmurControls_Light::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:AMUR.AmurControls.Light)
  GOOGLE_DCHECK_NE(&from, this);
  const AmurControls_Light* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AmurControls_Light>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:AMUR.AmurControls.Light)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:AMUR.AmurControls.Light)
    MergeFrom(*source);
  }
}

void AmurControls_Light::MergeFrom(const AmurControls_Light& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AMUR.AmurControls.Light)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.ledleftpower() != 0) {
    _internal_set_ledleftpower(from._internal_ledleftpower());
  }
  if (from.ledrightpower() != 0) {
    _internal_set_ledrightpower(from._internal_ledrightpower());
  }
}

void AmurControls_Light::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:AMUR.AmurControls.Light)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AmurControls_Light::CopyFrom(const AmurControls_Light& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AMUR.AmurControls.Light)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AmurControls_Light::IsInitialized() const {
  return true;
}

void AmurControls_Light::InternalSwap(AmurControls_Light* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AmurControls_Light, ledrightpower_)
      + sizeof(AmurControls_Light::ledrightpower_)
      - PROTOBUF_FIELD_OFFSET(AmurControls_Light, ledleftpower_)>(
          reinterpret_cast<char*>(&ledleftpower_),
          reinterpret_cast<char*>(&other->ledleftpower_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AmurControls_Light::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AmurControls_System::InitAsDefaultInstance() {
}
class AmurControls_System::_Internal {
 public:
};

AmurControls_System::AmurControls_System(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:AMUR.AmurControls.System)
}
AmurControls_System::AmurControls_System(const AmurControls_System& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  timeonamur_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_timeonamur().empty()) {
    timeonamur_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_timeonamur(),
      GetArena());
  }
  ::memcpy(&haltflag_, &from.haltflag_,
    static_cast<size_t>(reinterpret_cast<char*>(&restartflag_) -
    reinterpret_cast<char*>(&haltflag_)) + sizeof(restartflag_));
  // @@protoc_insertion_point(copy_constructor:AMUR.AmurControls.System)
}

void AmurControls_System::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AmurControls_System_amur_2eproto.base);
  timeonamur_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&haltflag_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&restartflag_) -
      reinterpret_cast<char*>(&haltflag_)) + sizeof(restartflag_));
}

AmurControls_System::~AmurControls_System() {
  // @@protoc_insertion_point(destructor:AMUR.AmurControls.System)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void AmurControls_System::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  timeonamur_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AmurControls_System::ArenaDtor(void* object) {
  AmurControls_System* _this = reinterpret_cast< AmurControls_System* >(object);
  (void)_this;
}
void AmurControls_System::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AmurControls_System::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AmurControls_System& AmurControls_System::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AmurControls_System_amur_2eproto.base);
  return *internal_default_instance();
}


void AmurControls_System::Clear() {
// @@protoc_insertion_point(message_clear_start:AMUR.AmurControls.System)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  timeonamur_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::memset(&haltflag_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&restartflag_) -
      reinterpret_cast<char*>(&haltflag_)) + sizeof(restartflag_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AmurControls_System::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // bool haltFlag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          haltflag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool restartFlag = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          restartflag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // string timeOnAmur = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_timeonamur();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "AMUR.AmurControls.System.timeOnAmur"));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AmurControls_System::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AMUR.AmurControls.System)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bool haltFlag = 1;
  if (this->haltflag() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_haltflag(), target);
  }

  // bool restartFlag = 2;
  if (this->restartflag() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_restartflag(), target);
  }

  // string timeOnAmur = 3;
  if (this->timeonamur().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_timeonamur().data(), static_cast<int>(this->_internal_timeonamur().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "AMUR.AmurControls.System.timeOnAmur");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_timeonamur(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AMUR.AmurControls.System)
  return target;
}

size_t AmurControls_System::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AMUR.AmurControls.System)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string timeOnAmur = 3;
  if (this->timeonamur().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_timeonamur());
  }

  // bool haltFlag = 1;
  if (this->haltflag() != 0) {
    total_size += 1 + 1;
  }

  // bool restartFlag = 2;
  if (this->restartflag() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AmurControls_System::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:AMUR.AmurControls.System)
  GOOGLE_DCHECK_NE(&from, this);
  const AmurControls_System* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AmurControls_System>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:AMUR.AmurControls.System)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:AMUR.AmurControls.System)
    MergeFrom(*source);
  }
}

void AmurControls_System::MergeFrom(const AmurControls_System& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AMUR.AmurControls.System)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.timeonamur().size() > 0) {
    _internal_set_timeonamur(from._internal_timeonamur());
  }
  if (from.haltflag() != 0) {
    _internal_set_haltflag(from._internal_haltflag());
  }
  if (from.restartflag() != 0) {
    _internal_set_restartflag(from._internal_restartflag());
  }
}

void AmurControls_System::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:AMUR.AmurControls.System)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AmurControls_System::CopyFrom(const AmurControls_System& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AMUR.AmurControls.System)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AmurControls_System::IsInitialized() const {
  return true;
}

void AmurControls_System::InternalSwap(AmurControls_System* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  timeonamur_.Swap(&other->timeonamur_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AmurControls_System, restartflag_)
      + sizeof(AmurControls_System::restartflag_)
      - PROTOBUF_FIELD_OFFSET(AmurControls_System, haltflag_)>(
          reinterpret_cast<char*>(&haltflag_),
          reinterpret_cast<char*>(&other->haltflag_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AmurControls_System::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AmurControls::InitAsDefaultInstance() {
  ::AMUR::_AmurControls_default_instance_._instance.get_mutable()->cameraservos_ = const_cast< ::AMUR::AmurControls_CameraServos*>(
      ::AMUR::AmurControls_CameraServos::internal_default_instance());
  ::AMUR::_AmurControls_default_instance_._instance.get_mutable()->wheelmotors_ = const_cast< ::AMUR::AmurControls_WheelMotors*>(
      ::AMUR::AmurControls_WheelMotors::internal_default_instance());
  ::AMUR::_AmurControls_default_instance_._instance.get_mutable()->handmotors_ = const_cast< ::AMUR::AmurControls_HandMotors*>(
      ::AMUR::AmurControls_HandMotors::internal_default_instance());
  ::AMUR::_AmurControls_default_instance_._instance.get_mutable()->light_ = const_cast< ::AMUR::AmurControls_Light*>(
      ::AMUR::AmurControls_Light::internal_default_instance());
  ::AMUR::_AmurControls_default_instance_._instance.get_mutable()->system_ = const_cast< ::AMUR::AmurControls_System*>(
      ::AMUR::AmurControls_System::internal_default_instance());
}
class AmurControls::_Internal {
 public:
  static const ::AMUR::AmurControls_CameraServos& cameraservos(const AmurControls* msg);
  static const ::AMUR::AmurControls_WheelMotors& wheelmotors(const AmurControls* msg);
  static const ::AMUR::AmurControls_HandMotors& handmotors(const AmurControls* msg);
  static const ::AMUR::AmurControls_Light& light(const AmurControls* msg);
  static const ::AMUR::AmurControls_System& system(const AmurControls* msg);
};

const ::AMUR::AmurControls_CameraServos&
AmurControls::_Internal::cameraservos(const AmurControls* msg) {
  return *msg->cameraservos_;
}
const ::AMUR::AmurControls_WheelMotors&
AmurControls::_Internal::wheelmotors(const AmurControls* msg) {
  return *msg->wheelmotors_;
}
const ::AMUR::AmurControls_HandMotors&
AmurControls::_Internal::handmotors(const AmurControls* msg) {
  return *msg->handmotors_;
}
const ::AMUR::AmurControls_Light&
AmurControls::_Internal::light(const AmurControls* msg) {
  return *msg->light_;
}
const ::AMUR::AmurControls_System&
AmurControls::_Internal::system(const AmurControls* msg) {
  return *msg->system_;
}
AmurControls::AmurControls(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:AMUR.AmurControls)
}
AmurControls::AmurControls(const AmurControls& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_cameraservos()) {
    cameraservos_ = new ::AMUR::AmurControls_CameraServos(*from.cameraservos_);
  } else {
    cameraservos_ = nullptr;
  }
  if (from._internal_has_wheelmotors()) {
    wheelmotors_ = new ::AMUR::AmurControls_WheelMotors(*from.wheelmotors_);
  } else {
    wheelmotors_ = nullptr;
  }
  if (from._internal_has_handmotors()) {
    handmotors_ = new ::AMUR::AmurControls_HandMotors(*from.handmotors_);
  } else {
    handmotors_ = nullptr;
  }
  if (from._internal_has_light()) {
    light_ = new ::AMUR::AmurControls_Light(*from.light_);
  } else {
    light_ = nullptr;
  }
  if (from._internal_has_system()) {
    system_ = new ::AMUR::AmurControls_System(*from.system_);
  } else {
    system_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:AMUR.AmurControls)
}

void AmurControls::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AmurControls_amur_2eproto.base);
  ::memset(&cameraservos_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&system_) -
      reinterpret_cast<char*>(&cameraservos_)) + sizeof(system_));
}

AmurControls::~AmurControls() {
  // @@protoc_insertion_point(destructor:AMUR.AmurControls)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void AmurControls::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete cameraservos_;
  if (this != internal_default_instance()) delete wheelmotors_;
  if (this != internal_default_instance()) delete handmotors_;
  if (this != internal_default_instance()) delete light_;
  if (this != internal_default_instance()) delete system_;
}

void AmurControls::ArenaDtor(void* object) {
  AmurControls* _this = reinterpret_cast< AmurControls* >(object);
  (void)_this;
}
void AmurControls::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AmurControls::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AmurControls& AmurControls::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AmurControls_amur_2eproto.base);
  return *internal_default_instance();
}


void AmurControls::Clear() {
// @@protoc_insertion_point(message_clear_start:AMUR.AmurControls)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArena() == nullptr && cameraservos_ != nullptr) {
    delete cameraservos_;
  }
  cameraservos_ = nullptr;
  if (GetArena() == nullptr && wheelmotors_ != nullptr) {
    delete wheelmotors_;
  }
  wheelmotors_ = nullptr;
  if (GetArena() == nullptr && handmotors_ != nullptr) {
    delete handmotors_;
  }
  handmotors_ = nullptr;
  if (GetArena() == nullptr && light_ != nullptr) {
    delete light_;
  }
  light_ = nullptr;
  if (GetArena() == nullptr && system_ != nullptr) {
    delete system_;
  }
  system_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AmurControls::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .AMUR.AmurControls.CameraServos cameraServos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_cameraservos(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .AMUR.AmurControls.WheelMotors wheelMotors = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_wheelmotors(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .AMUR.AmurControls.HandMotors handMotors = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_handmotors(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .AMUR.AmurControls.Light light = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_light(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .AMUR.AmurControls.System system = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_system(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AmurControls::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AMUR.AmurControls)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .AMUR.AmurControls.CameraServos cameraServos = 1;
  if (this->has_cameraservos()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::cameraservos(this), target, stream);
  }

  // .AMUR.AmurControls.WheelMotors wheelMotors = 2;
  if (this->has_wheelmotors()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::wheelmotors(this), target, stream);
  }

  // .AMUR.AmurControls.HandMotors handMotors = 3;
  if (this->has_handmotors()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::handmotors(this), target, stream);
  }

  // .AMUR.AmurControls.Light light = 4;
  if (this->has_light()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::light(this), target, stream);
  }

  // .AMUR.AmurControls.System system = 5;
  if (this->has_system()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::system(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AMUR.AmurControls)
  return target;
}

size_t AmurControls::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AMUR.AmurControls)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .AMUR.AmurControls.CameraServos cameraServos = 1;
  if (this->has_cameraservos()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *cameraservos_);
  }

  // .AMUR.AmurControls.WheelMotors wheelMotors = 2;
  if (this->has_wheelmotors()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *wheelmotors_);
  }

  // .AMUR.AmurControls.HandMotors handMotors = 3;
  if (this->has_handmotors()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *handmotors_);
  }

  // .AMUR.AmurControls.Light light = 4;
  if (this->has_light()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *light_);
  }

  // .AMUR.AmurControls.System system = 5;
  if (this->has_system()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *system_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AmurControls::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:AMUR.AmurControls)
  GOOGLE_DCHECK_NE(&from, this);
  const AmurControls* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AmurControls>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:AMUR.AmurControls)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:AMUR.AmurControls)
    MergeFrom(*source);
  }
}

void AmurControls::MergeFrom(const AmurControls& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AMUR.AmurControls)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_cameraservos()) {
    _internal_mutable_cameraservos()->::AMUR::AmurControls_CameraServos::MergeFrom(from._internal_cameraservos());
  }
  if (from.has_wheelmotors()) {
    _internal_mutable_wheelmotors()->::AMUR::AmurControls_WheelMotors::MergeFrom(from._internal_wheelmotors());
  }
  if (from.has_handmotors()) {
    _internal_mutable_handmotors()->::AMUR::AmurControls_HandMotors::MergeFrom(from._internal_handmotors());
  }
  if (from.has_light()) {
    _internal_mutable_light()->::AMUR::AmurControls_Light::MergeFrom(from._internal_light());
  }
  if (from.has_system()) {
    _internal_mutable_system()->::AMUR::AmurControls_System::MergeFrom(from._internal_system());
  }
}

void AmurControls::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:AMUR.AmurControls)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AmurControls::CopyFrom(const AmurControls& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AMUR.AmurControls)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AmurControls::IsInitialized() const {
  return true;
}

void AmurControls::InternalSwap(AmurControls* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AmurControls, system_)
      + sizeof(AmurControls::system_)
      - PROTOBUF_FIELD_OFFSET(AmurControls, cameraservos_)>(
          reinterpret_cast<char*>(&cameraservos_),
          reinterpret_cast<char*>(&other->cameraservos_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AmurControls::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AmurSensors_Accelerometer::InitAsDefaultInstance() {
}
class AmurSensors_Accelerometer::_Internal {
 public:
};

AmurSensors_Accelerometer::AmurSensors_Accelerometer(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:AMUR.AmurSensors.Accelerometer)
}
AmurSensors_Accelerometer::AmurSensors_Accelerometer(const AmurSensors_Accelerometer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
  // @@protoc_insertion_point(copy_constructor:AMUR.AmurSensors.Accelerometer)
}

void AmurSensors_Accelerometer::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&z_) -
      reinterpret_cast<char*>(&x_)) + sizeof(z_));
}

AmurSensors_Accelerometer::~AmurSensors_Accelerometer() {
  // @@protoc_insertion_point(destructor:AMUR.AmurSensors.Accelerometer)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void AmurSensors_Accelerometer::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void AmurSensors_Accelerometer::ArenaDtor(void* object) {
  AmurSensors_Accelerometer* _this = reinterpret_cast< AmurSensors_Accelerometer* >(object);
  (void)_this;
}
void AmurSensors_Accelerometer::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AmurSensors_Accelerometer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AmurSensors_Accelerometer& AmurSensors_Accelerometer::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AmurSensors_Accelerometer_amur_2eproto.base);
  return *internal_default_instance();
}


void AmurSensors_Accelerometer::Clear() {
// @@protoc_insertion_point(message_clear_start:AMUR.AmurSensors.Accelerometer)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&z_) -
      reinterpret_cast<char*>(&x_)) + sizeof(z_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AmurSensors_Accelerometer::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AmurSensors_Accelerometer::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AMUR.AmurSensors.Accelerometer)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  if (!(this->x() <= 0 && this->x() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // float y = 2;
  if (!(this->y() <= 0 && this->y() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // float z = 3;
  if (!(this->z() <= 0 && this->z() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AMUR.AmurSensors.Accelerometer)
  return target;
}

size_t AmurSensors_Accelerometer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AMUR.AmurSensors.Accelerometer)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  if (!(this->x() <= 0 && this->x() >= 0)) {
    total_size += 1 + 4;
  }

  // float y = 2;
  if (!(this->y() <= 0 && this->y() >= 0)) {
    total_size += 1 + 4;
  }

  // float z = 3;
  if (!(this->z() <= 0 && this->z() >= 0)) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AmurSensors_Accelerometer::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:AMUR.AmurSensors.Accelerometer)
  GOOGLE_DCHECK_NE(&from, this);
  const AmurSensors_Accelerometer* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AmurSensors_Accelerometer>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:AMUR.AmurSensors.Accelerometer)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:AMUR.AmurSensors.Accelerometer)
    MergeFrom(*source);
  }
}

void AmurSensors_Accelerometer::MergeFrom(const AmurSensors_Accelerometer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AMUR.AmurSensors.Accelerometer)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!(from.x() <= 0 && from.x() >= 0)) {
    _internal_set_x(from._internal_x());
  }
  if (!(from.y() <= 0 && from.y() >= 0)) {
    _internal_set_y(from._internal_y());
  }
  if (!(from.z() <= 0 && from.z() >= 0)) {
    _internal_set_z(from._internal_z());
  }
}

void AmurSensors_Accelerometer::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:AMUR.AmurSensors.Accelerometer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AmurSensors_Accelerometer::CopyFrom(const AmurSensors_Accelerometer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AMUR.AmurSensors.Accelerometer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AmurSensors_Accelerometer::IsInitialized() const {
  return true;
}

void AmurSensors_Accelerometer::InternalSwap(AmurSensors_Accelerometer* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AmurSensors_Accelerometer, z_)
      + sizeof(AmurSensors_Accelerometer::z_)
      - PROTOBUF_FIELD_OFFSET(AmurSensors_Accelerometer, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AmurSensors_Accelerometer::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AmurSensors_Gyroscope::InitAsDefaultInstance() {
}
class AmurSensors_Gyroscope::_Internal {
 public:
};

AmurSensors_Gyroscope::AmurSensors_Gyroscope(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:AMUR.AmurSensors.Gyroscope)
}
AmurSensors_Gyroscope::AmurSensors_Gyroscope(const AmurSensors_Gyroscope& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
  // @@protoc_insertion_point(copy_constructor:AMUR.AmurSensors.Gyroscope)
}

void AmurSensors_Gyroscope::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&z_) -
      reinterpret_cast<char*>(&x_)) + sizeof(z_));
}

AmurSensors_Gyroscope::~AmurSensors_Gyroscope() {
  // @@protoc_insertion_point(destructor:AMUR.AmurSensors.Gyroscope)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void AmurSensors_Gyroscope::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void AmurSensors_Gyroscope::ArenaDtor(void* object) {
  AmurSensors_Gyroscope* _this = reinterpret_cast< AmurSensors_Gyroscope* >(object);
  (void)_this;
}
void AmurSensors_Gyroscope::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AmurSensors_Gyroscope::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AmurSensors_Gyroscope& AmurSensors_Gyroscope::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AmurSensors_Gyroscope_amur_2eproto.base);
  return *internal_default_instance();
}


void AmurSensors_Gyroscope::Clear() {
// @@protoc_insertion_point(message_clear_start:AMUR.AmurSensors.Gyroscope)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&z_) -
      reinterpret_cast<char*>(&x_)) + sizeof(z_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AmurSensors_Gyroscope::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AmurSensors_Gyroscope::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AMUR.AmurSensors.Gyroscope)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  if (!(this->x() <= 0 && this->x() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // float y = 2;
  if (!(this->y() <= 0 && this->y() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // float z = 3;
  if (!(this->z() <= 0 && this->z() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AMUR.AmurSensors.Gyroscope)
  return target;
}

size_t AmurSensors_Gyroscope::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AMUR.AmurSensors.Gyroscope)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  if (!(this->x() <= 0 && this->x() >= 0)) {
    total_size += 1 + 4;
  }

  // float y = 2;
  if (!(this->y() <= 0 && this->y() >= 0)) {
    total_size += 1 + 4;
  }

  // float z = 3;
  if (!(this->z() <= 0 && this->z() >= 0)) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AmurSensors_Gyroscope::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:AMUR.AmurSensors.Gyroscope)
  GOOGLE_DCHECK_NE(&from, this);
  const AmurSensors_Gyroscope* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AmurSensors_Gyroscope>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:AMUR.AmurSensors.Gyroscope)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:AMUR.AmurSensors.Gyroscope)
    MergeFrom(*source);
  }
}

void AmurSensors_Gyroscope::MergeFrom(const AmurSensors_Gyroscope& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AMUR.AmurSensors.Gyroscope)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!(from.x() <= 0 && from.x() >= 0)) {
    _internal_set_x(from._internal_x());
  }
  if (!(from.y() <= 0 && from.y() >= 0)) {
    _internal_set_y(from._internal_y());
  }
  if (!(from.z() <= 0 && from.z() >= 0)) {
    _internal_set_z(from._internal_z());
  }
}

void AmurSensors_Gyroscope::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:AMUR.AmurSensors.Gyroscope)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AmurSensors_Gyroscope::CopyFrom(const AmurSensors_Gyroscope& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AMUR.AmurSensors.Gyroscope)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AmurSensors_Gyroscope::IsInitialized() const {
  return true;
}

void AmurSensors_Gyroscope::InternalSwap(AmurSensors_Gyroscope* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AmurSensors_Gyroscope, z_)
      + sizeof(AmurSensors_Gyroscope::z_)
      - PROTOBUF_FIELD_OFFSET(AmurSensors_Gyroscope, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AmurSensors_Gyroscope::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AmurSensors_Magnitometer::InitAsDefaultInstance() {
}
class AmurSensors_Magnitometer::_Internal {
 public:
};

AmurSensors_Magnitometer::AmurSensors_Magnitometer(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:AMUR.AmurSensors.Magnitometer)
}
AmurSensors_Magnitometer::AmurSensors_Magnitometer(const AmurSensors_Magnitometer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
  // @@protoc_insertion_point(copy_constructor:AMUR.AmurSensors.Magnitometer)
}

void AmurSensors_Magnitometer::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&z_) -
      reinterpret_cast<char*>(&x_)) + sizeof(z_));
}

AmurSensors_Magnitometer::~AmurSensors_Magnitometer() {
  // @@protoc_insertion_point(destructor:AMUR.AmurSensors.Magnitometer)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void AmurSensors_Magnitometer::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void AmurSensors_Magnitometer::ArenaDtor(void* object) {
  AmurSensors_Magnitometer* _this = reinterpret_cast< AmurSensors_Magnitometer* >(object);
  (void)_this;
}
void AmurSensors_Magnitometer::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AmurSensors_Magnitometer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AmurSensors_Magnitometer& AmurSensors_Magnitometer::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AmurSensors_Magnitometer_amur_2eproto.base);
  return *internal_default_instance();
}


void AmurSensors_Magnitometer::Clear() {
// @@protoc_insertion_point(message_clear_start:AMUR.AmurSensors.Magnitometer)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&z_) -
      reinterpret_cast<char*>(&x_)) + sizeof(z_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AmurSensors_Magnitometer::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AmurSensors_Magnitometer::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AMUR.AmurSensors.Magnitometer)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  if (!(this->x() <= 0 && this->x() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // float y = 2;
  if (!(this->y() <= 0 && this->y() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // float z = 3;
  if (!(this->z() <= 0 && this->z() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AMUR.AmurSensors.Magnitometer)
  return target;
}

size_t AmurSensors_Magnitometer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AMUR.AmurSensors.Magnitometer)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  if (!(this->x() <= 0 && this->x() >= 0)) {
    total_size += 1 + 4;
  }

  // float y = 2;
  if (!(this->y() <= 0 && this->y() >= 0)) {
    total_size += 1 + 4;
  }

  // float z = 3;
  if (!(this->z() <= 0 && this->z() >= 0)) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AmurSensors_Magnitometer::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:AMUR.AmurSensors.Magnitometer)
  GOOGLE_DCHECK_NE(&from, this);
  const AmurSensors_Magnitometer* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AmurSensors_Magnitometer>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:AMUR.AmurSensors.Magnitometer)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:AMUR.AmurSensors.Magnitometer)
    MergeFrom(*source);
  }
}

void AmurSensors_Magnitometer::MergeFrom(const AmurSensors_Magnitometer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AMUR.AmurSensors.Magnitometer)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!(from.x() <= 0 && from.x() >= 0)) {
    _internal_set_x(from._internal_x());
  }
  if (!(from.y() <= 0 && from.y() >= 0)) {
    _internal_set_y(from._internal_y());
  }
  if (!(from.z() <= 0 && from.z() >= 0)) {
    _internal_set_z(from._internal_z());
  }
}

void AmurSensors_Magnitometer::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:AMUR.AmurSensors.Magnitometer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AmurSensors_Magnitometer::CopyFrom(const AmurSensors_Magnitometer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AMUR.AmurSensors.Magnitometer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AmurSensors_Magnitometer::IsInitialized() const {
  return true;
}

void AmurSensors_Magnitometer::InternalSwap(AmurSensors_Magnitometer* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AmurSensors_Magnitometer, z_)
      + sizeof(AmurSensors_Magnitometer::z_)
      - PROTOBUF_FIELD_OFFSET(AmurSensors_Magnitometer, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AmurSensors_Magnitometer::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AmurSensors_WheelEncoders::InitAsDefaultInstance() {
}
class AmurSensors_WheelEncoders::_Internal {
 public:
};

AmurSensors_WheelEncoders::AmurSensors_WheelEncoders(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:AMUR.AmurSensors.WheelEncoders)
}
AmurSensors_WheelEncoders::AmurSensors_WheelEncoders(const AmurSensors_WheelEncoders& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&leftangle_, &from.leftangle_,
    static_cast<size_t>(reinterpret_cast<char*>(&rightangle_) -
    reinterpret_cast<char*>(&leftangle_)) + sizeof(rightangle_));
  // @@protoc_insertion_point(copy_constructor:AMUR.AmurSensors.WheelEncoders)
}

void AmurSensors_WheelEncoders::SharedCtor() {
  ::memset(&leftangle_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&rightangle_) -
      reinterpret_cast<char*>(&leftangle_)) + sizeof(rightangle_));
}

AmurSensors_WheelEncoders::~AmurSensors_WheelEncoders() {
  // @@protoc_insertion_point(destructor:AMUR.AmurSensors.WheelEncoders)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void AmurSensors_WheelEncoders::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void AmurSensors_WheelEncoders::ArenaDtor(void* object) {
  AmurSensors_WheelEncoders* _this = reinterpret_cast< AmurSensors_WheelEncoders* >(object);
  (void)_this;
}
void AmurSensors_WheelEncoders::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AmurSensors_WheelEncoders::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AmurSensors_WheelEncoders& AmurSensors_WheelEncoders::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AmurSensors_WheelEncoders_amur_2eproto.base);
  return *internal_default_instance();
}


void AmurSensors_WheelEncoders::Clear() {
// @@protoc_insertion_point(message_clear_start:AMUR.AmurSensors.WheelEncoders)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&leftangle_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&rightangle_) -
      reinterpret_cast<char*>(&leftangle_)) + sizeof(rightangle_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AmurSensors_WheelEncoders::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // int32 leftAngle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          leftangle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 rightAngle = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          rightangle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AmurSensors_WheelEncoders::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AMUR.AmurSensors.WheelEncoders)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 leftAngle = 1;
  if (this->leftangle() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_leftangle(), target);
  }

  // int32 rightAngle = 2;
  if (this->rightangle() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_rightangle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AMUR.AmurSensors.WheelEncoders)
  return target;
}

size_t AmurSensors_WheelEncoders::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AMUR.AmurSensors.WheelEncoders)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 leftAngle = 1;
  if (this->leftangle() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_leftangle());
  }

  // int32 rightAngle = 2;
  if (this->rightangle() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_rightangle());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AmurSensors_WheelEncoders::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:AMUR.AmurSensors.WheelEncoders)
  GOOGLE_DCHECK_NE(&from, this);
  const AmurSensors_WheelEncoders* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AmurSensors_WheelEncoders>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:AMUR.AmurSensors.WheelEncoders)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:AMUR.AmurSensors.WheelEncoders)
    MergeFrom(*source);
  }
}

void AmurSensors_WheelEncoders::MergeFrom(const AmurSensors_WheelEncoders& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AMUR.AmurSensors.WheelEncoders)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.leftangle() != 0) {
    _internal_set_leftangle(from._internal_leftangle());
  }
  if (from.rightangle() != 0) {
    _internal_set_rightangle(from._internal_rightangle());
  }
}

void AmurSensors_WheelEncoders::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:AMUR.AmurSensors.WheelEncoders)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AmurSensors_WheelEncoders::CopyFrom(const AmurSensors_WheelEncoders& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AMUR.AmurSensors.WheelEncoders)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AmurSensors_WheelEncoders::IsInitialized() const {
  return true;
}

void AmurSensors_WheelEncoders::InternalSwap(AmurSensors_WheelEncoders* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AmurSensors_WheelEncoders, rightangle_)
      + sizeof(AmurSensors_WheelEncoders::rightangle_)
      - PROTOBUF_FIELD_OFFSET(AmurSensors_WheelEncoders, leftangle_)>(
          reinterpret_cast<char*>(&leftangle_),
          reinterpret_cast<char*>(&other->leftangle_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AmurSensors_WheelEncoders::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AmurSensors_HandEncoders::InitAsDefaultInstance() {
}
class AmurSensors_HandEncoders::_Internal {
 public:
};

AmurSensors_HandEncoders::AmurSensors_HandEncoders(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:AMUR.AmurSensors.HandEncoders)
}
AmurSensors_HandEncoders::AmurSensors_HandEncoders(const AmurSensors_HandEncoders& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&leftinternalangle_, &from.leftinternalangle_,
    static_cast<size_t>(reinterpret_cast<char*>(&rightouterangle_) -
    reinterpret_cast<char*>(&leftinternalangle_)) + sizeof(rightouterangle_));
  // @@protoc_insertion_point(copy_constructor:AMUR.AmurSensors.HandEncoders)
}

void AmurSensors_HandEncoders::SharedCtor() {
  ::memset(&leftinternalangle_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&rightouterangle_) -
      reinterpret_cast<char*>(&leftinternalangle_)) + sizeof(rightouterangle_));
}

AmurSensors_HandEncoders::~AmurSensors_HandEncoders() {
  // @@protoc_insertion_point(destructor:AMUR.AmurSensors.HandEncoders)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void AmurSensors_HandEncoders::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void AmurSensors_HandEncoders::ArenaDtor(void* object) {
  AmurSensors_HandEncoders* _this = reinterpret_cast< AmurSensors_HandEncoders* >(object);
  (void)_this;
}
void AmurSensors_HandEncoders::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AmurSensors_HandEncoders::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AmurSensors_HandEncoders& AmurSensors_HandEncoders::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AmurSensors_HandEncoders_amur_2eproto.base);
  return *internal_default_instance();
}


void AmurSensors_HandEncoders::Clear() {
// @@protoc_insertion_point(message_clear_start:AMUR.AmurSensors.HandEncoders)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&leftinternalangle_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&rightouterangle_) -
      reinterpret_cast<char*>(&leftinternalangle_)) + sizeof(rightouterangle_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AmurSensors_HandEncoders::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // int32 leftInternalAngle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          leftinternalangle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 rightInternalAngle = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          rightinternalangle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 leftOuterAngle = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          leftouterangle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 rightOuterAngle = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          rightouterangle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AmurSensors_HandEncoders::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AMUR.AmurSensors.HandEncoders)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 leftInternalAngle = 1;
  if (this->leftinternalangle() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_leftinternalangle(), target);
  }

  // int32 rightInternalAngle = 2;
  if (this->rightinternalangle() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_rightinternalangle(), target);
  }

  // int32 leftOuterAngle = 3;
  if (this->leftouterangle() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_leftouterangle(), target);
  }

  // int32 rightOuterAngle = 4;
  if (this->rightouterangle() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_rightouterangle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AMUR.AmurSensors.HandEncoders)
  return target;
}

size_t AmurSensors_HandEncoders::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AMUR.AmurSensors.HandEncoders)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 leftInternalAngle = 1;
  if (this->leftinternalangle() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_leftinternalangle());
  }

  // int32 rightInternalAngle = 2;
  if (this->rightinternalangle() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_rightinternalangle());
  }

  // int32 leftOuterAngle = 3;
  if (this->leftouterangle() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_leftouterangle());
  }

  // int32 rightOuterAngle = 4;
  if (this->rightouterangle() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_rightouterangle());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AmurSensors_HandEncoders::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:AMUR.AmurSensors.HandEncoders)
  GOOGLE_DCHECK_NE(&from, this);
  const AmurSensors_HandEncoders* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AmurSensors_HandEncoders>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:AMUR.AmurSensors.HandEncoders)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:AMUR.AmurSensors.HandEncoders)
    MergeFrom(*source);
  }
}

void AmurSensors_HandEncoders::MergeFrom(const AmurSensors_HandEncoders& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AMUR.AmurSensors.HandEncoders)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.leftinternalangle() != 0) {
    _internal_set_leftinternalangle(from._internal_leftinternalangle());
  }
  if (from.rightinternalangle() != 0) {
    _internal_set_rightinternalangle(from._internal_rightinternalangle());
  }
  if (from.leftouterangle() != 0) {
    _internal_set_leftouterangle(from._internal_leftouterangle());
  }
  if (from.rightouterangle() != 0) {
    _internal_set_rightouterangle(from._internal_rightouterangle());
  }
}

void AmurSensors_HandEncoders::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:AMUR.AmurSensors.HandEncoders)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AmurSensors_HandEncoders::CopyFrom(const AmurSensors_HandEncoders& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AMUR.AmurSensors.HandEncoders)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AmurSensors_HandEncoders::IsInitialized() const {
  return true;
}

void AmurSensors_HandEncoders::InternalSwap(AmurSensors_HandEncoders* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AmurSensors_HandEncoders, rightouterangle_)
      + sizeof(AmurSensors_HandEncoders::rightouterangle_)
      - PROTOBUF_FIELD_OFFSET(AmurSensors_HandEncoders, leftinternalangle_)>(
          reinterpret_cast<char*>(&leftinternalangle_),
          reinterpret_cast<char*>(&other->leftinternalangle_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AmurSensors_HandEncoders::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AmurSensors_Temperature::InitAsDefaultInstance() {
}
class AmurSensors_Temperature::_Internal {
 public:
};

AmurSensors_Temperature::AmurSensors_Temperature(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:AMUR.AmurSensors.Temperature)
}
AmurSensors_Temperature::AmurSensors_Temperature(const AmurSensors_Temperature& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&tempaccelerometer_, &from.tempaccelerometer_,
    static_cast<size_t>(reinterpret_cast<char*>(&temppressure_) -
    reinterpret_cast<char*>(&tempaccelerometer_)) + sizeof(temppressure_));
  // @@protoc_insertion_point(copy_constructor:AMUR.AmurSensors.Temperature)
}

void AmurSensors_Temperature::SharedCtor() {
  ::memset(&tempaccelerometer_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&temppressure_) -
      reinterpret_cast<char*>(&tempaccelerometer_)) + sizeof(temppressure_));
}

AmurSensors_Temperature::~AmurSensors_Temperature() {
  // @@protoc_insertion_point(destructor:AMUR.AmurSensors.Temperature)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void AmurSensors_Temperature::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void AmurSensors_Temperature::ArenaDtor(void* object) {
  AmurSensors_Temperature* _this = reinterpret_cast< AmurSensors_Temperature* >(object);
  (void)_this;
}
void AmurSensors_Temperature::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AmurSensors_Temperature::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AmurSensors_Temperature& AmurSensors_Temperature::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AmurSensors_Temperature_amur_2eproto.base);
  return *internal_default_instance();
}


void AmurSensors_Temperature::Clear() {
// @@protoc_insertion_point(message_clear_start:AMUR.AmurSensors.Temperature)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&tempaccelerometer_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&temppressure_) -
      reinterpret_cast<char*>(&tempaccelerometer_)) + sizeof(temppressure_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AmurSensors_Temperature::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // int32 tempAccelerometer = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          tempaccelerometer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 tempCPU = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          tempcpu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 tempPressure = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          temppressure_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AmurSensors_Temperature::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AMUR.AmurSensors.Temperature)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 tempAccelerometer = 1;
  if (this->tempaccelerometer() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_tempaccelerometer(), target);
  }

  // int32 tempCPU = 2;
  if (this->tempcpu() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_tempcpu(), target);
  }

  // int32 tempPressure = 3;
  if (this->temppressure() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_temppressure(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AMUR.AmurSensors.Temperature)
  return target;
}

size_t AmurSensors_Temperature::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AMUR.AmurSensors.Temperature)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 tempAccelerometer = 1;
  if (this->tempaccelerometer() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_tempaccelerometer());
  }

  // int32 tempCPU = 2;
  if (this->tempcpu() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_tempcpu());
  }

  // int32 tempPressure = 3;
  if (this->temppressure() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_temppressure());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AmurSensors_Temperature::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:AMUR.AmurSensors.Temperature)
  GOOGLE_DCHECK_NE(&from, this);
  const AmurSensors_Temperature* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AmurSensors_Temperature>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:AMUR.AmurSensors.Temperature)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:AMUR.AmurSensors.Temperature)
    MergeFrom(*source);
  }
}

void AmurSensors_Temperature::MergeFrom(const AmurSensors_Temperature& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AMUR.AmurSensors.Temperature)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.tempaccelerometer() != 0) {
    _internal_set_tempaccelerometer(from._internal_tempaccelerometer());
  }
  if (from.tempcpu() != 0) {
    _internal_set_tempcpu(from._internal_tempcpu());
  }
  if (from.temppressure() != 0) {
    _internal_set_temppressure(from._internal_temppressure());
  }
}

void AmurSensors_Temperature::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:AMUR.AmurSensors.Temperature)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AmurSensors_Temperature::CopyFrom(const AmurSensors_Temperature& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AMUR.AmurSensors.Temperature)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AmurSensors_Temperature::IsInitialized() const {
  return true;
}

void AmurSensors_Temperature::InternalSwap(AmurSensors_Temperature* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AmurSensors_Temperature, temppressure_)
      + sizeof(AmurSensors_Temperature::temppressure_)
      - PROTOBUF_FIELD_OFFSET(AmurSensors_Temperature, tempaccelerometer_)>(
          reinterpret_cast<char*>(&tempaccelerometer_),
          reinterpret_cast<char*>(&other->tempaccelerometer_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AmurSensors_Temperature::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AmurSensors_WheelCurrent::InitAsDefaultInstance() {
}
class AmurSensors_WheelCurrent::_Internal {
 public:
};

AmurSensors_WheelCurrent::AmurSensors_WheelCurrent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:AMUR.AmurSensors.WheelCurrent)
}
AmurSensors_WheelCurrent::AmurSensors_WheelCurrent(const AmurSensors_WheelCurrent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&leftcurrent_, &from.leftcurrent_,
    static_cast<size_t>(reinterpret_cast<char*>(&rightcurrent_) -
    reinterpret_cast<char*>(&leftcurrent_)) + sizeof(rightcurrent_));
  // @@protoc_insertion_point(copy_constructor:AMUR.AmurSensors.WheelCurrent)
}

void AmurSensors_WheelCurrent::SharedCtor() {
  ::memset(&leftcurrent_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&rightcurrent_) -
      reinterpret_cast<char*>(&leftcurrent_)) + sizeof(rightcurrent_));
}

AmurSensors_WheelCurrent::~AmurSensors_WheelCurrent() {
  // @@protoc_insertion_point(destructor:AMUR.AmurSensors.WheelCurrent)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void AmurSensors_WheelCurrent::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void AmurSensors_WheelCurrent::ArenaDtor(void* object) {
  AmurSensors_WheelCurrent* _this = reinterpret_cast< AmurSensors_WheelCurrent* >(object);
  (void)_this;
}
void AmurSensors_WheelCurrent::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AmurSensors_WheelCurrent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AmurSensors_WheelCurrent& AmurSensors_WheelCurrent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AmurSensors_WheelCurrent_amur_2eproto.base);
  return *internal_default_instance();
}


void AmurSensors_WheelCurrent::Clear() {
// @@protoc_insertion_point(message_clear_start:AMUR.AmurSensors.WheelCurrent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&leftcurrent_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&rightcurrent_) -
      reinterpret_cast<char*>(&leftcurrent_)) + sizeof(rightcurrent_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AmurSensors_WheelCurrent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // uint32 leftCurrent = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          leftcurrent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 rightCurrent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          rightcurrent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AmurSensors_WheelCurrent::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AMUR.AmurSensors.WheelCurrent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 leftCurrent = 1;
  if (this->leftcurrent() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_leftcurrent(), target);
  }

  // uint32 rightCurrent = 2;
  if (this->rightcurrent() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_rightcurrent(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AMUR.AmurSensors.WheelCurrent)
  return target;
}

size_t AmurSensors_WheelCurrent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AMUR.AmurSensors.WheelCurrent)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 leftCurrent = 1;
  if (this->leftcurrent() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_leftcurrent());
  }

  // uint32 rightCurrent = 2;
  if (this->rightcurrent() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_rightcurrent());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AmurSensors_WheelCurrent::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:AMUR.AmurSensors.WheelCurrent)
  GOOGLE_DCHECK_NE(&from, this);
  const AmurSensors_WheelCurrent* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AmurSensors_WheelCurrent>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:AMUR.AmurSensors.WheelCurrent)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:AMUR.AmurSensors.WheelCurrent)
    MergeFrom(*source);
  }
}

void AmurSensors_WheelCurrent::MergeFrom(const AmurSensors_WheelCurrent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AMUR.AmurSensors.WheelCurrent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.leftcurrent() != 0) {
    _internal_set_leftcurrent(from._internal_leftcurrent());
  }
  if (from.rightcurrent() != 0) {
    _internal_set_rightcurrent(from._internal_rightcurrent());
  }
}

void AmurSensors_WheelCurrent::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:AMUR.AmurSensors.WheelCurrent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AmurSensors_WheelCurrent::CopyFrom(const AmurSensors_WheelCurrent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AMUR.AmurSensors.WheelCurrent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AmurSensors_WheelCurrent::IsInitialized() const {
  return true;
}

void AmurSensors_WheelCurrent::InternalSwap(AmurSensors_WheelCurrent* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AmurSensors_WheelCurrent, rightcurrent_)
      + sizeof(AmurSensors_WheelCurrent::rightcurrent_)
      - PROTOBUF_FIELD_OFFSET(AmurSensors_WheelCurrent, leftcurrent_)>(
          reinterpret_cast<char*>(&leftcurrent_),
          reinterpret_cast<char*>(&other->leftcurrent_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AmurSensors_WheelCurrent::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AmurSensors_HandCurrent::InitAsDefaultInstance() {
}
class AmurSensors_HandCurrent::_Internal {
 public:
};

AmurSensors_HandCurrent::AmurSensors_HandCurrent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:AMUR.AmurSensors.HandCurrent)
}
AmurSensors_HandCurrent::AmurSensors_HandCurrent(const AmurSensors_HandCurrent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&leftcurrent_, &from.leftcurrent_,
    static_cast<size_t>(reinterpret_cast<char*>(&rightcurrent_) -
    reinterpret_cast<char*>(&leftcurrent_)) + sizeof(rightcurrent_));
  // @@protoc_insertion_point(copy_constructor:AMUR.AmurSensors.HandCurrent)
}

void AmurSensors_HandCurrent::SharedCtor() {
  ::memset(&leftcurrent_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&rightcurrent_) -
      reinterpret_cast<char*>(&leftcurrent_)) + sizeof(rightcurrent_));
}

AmurSensors_HandCurrent::~AmurSensors_HandCurrent() {
  // @@protoc_insertion_point(destructor:AMUR.AmurSensors.HandCurrent)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void AmurSensors_HandCurrent::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void AmurSensors_HandCurrent::ArenaDtor(void* object) {
  AmurSensors_HandCurrent* _this = reinterpret_cast< AmurSensors_HandCurrent* >(object);
  (void)_this;
}
void AmurSensors_HandCurrent::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AmurSensors_HandCurrent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AmurSensors_HandCurrent& AmurSensors_HandCurrent::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AmurSensors_HandCurrent_amur_2eproto.base);
  return *internal_default_instance();
}


void AmurSensors_HandCurrent::Clear() {
// @@protoc_insertion_point(message_clear_start:AMUR.AmurSensors.HandCurrent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&leftcurrent_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&rightcurrent_) -
      reinterpret_cast<char*>(&leftcurrent_)) + sizeof(rightcurrent_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AmurSensors_HandCurrent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // uint32 leftCurrent = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          leftcurrent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 rightCurrent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          rightcurrent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AmurSensors_HandCurrent::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AMUR.AmurSensors.HandCurrent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 leftCurrent = 1;
  if (this->leftcurrent() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_leftcurrent(), target);
  }

  // uint32 rightCurrent = 2;
  if (this->rightcurrent() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_rightcurrent(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AMUR.AmurSensors.HandCurrent)
  return target;
}

size_t AmurSensors_HandCurrent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AMUR.AmurSensors.HandCurrent)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 leftCurrent = 1;
  if (this->leftcurrent() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_leftcurrent());
  }

  // uint32 rightCurrent = 2;
  if (this->rightcurrent() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_rightcurrent());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AmurSensors_HandCurrent::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:AMUR.AmurSensors.HandCurrent)
  GOOGLE_DCHECK_NE(&from, this);
  const AmurSensors_HandCurrent* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AmurSensors_HandCurrent>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:AMUR.AmurSensors.HandCurrent)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:AMUR.AmurSensors.HandCurrent)
    MergeFrom(*source);
  }
}

void AmurSensors_HandCurrent::MergeFrom(const AmurSensors_HandCurrent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AMUR.AmurSensors.HandCurrent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.leftcurrent() != 0) {
    _internal_set_leftcurrent(from._internal_leftcurrent());
  }
  if (from.rightcurrent() != 0) {
    _internal_set_rightcurrent(from._internal_rightcurrent());
  }
}

void AmurSensors_HandCurrent::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:AMUR.AmurSensors.HandCurrent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AmurSensors_HandCurrent::CopyFrom(const AmurSensors_HandCurrent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AMUR.AmurSensors.HandCurrent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AmurSensors_HandCurrent::IsInitialized() const {
  return true;
}

void AmurSensors_HandCurrent::InternalSwap(AmurSensors_HandCurrent* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AmurSensors_HandCurrent, rightcurrent_)
      + sizeof(AmurSensors_HandCurrent::rightcurrent_)
      - PROTOBUF_FIELD_OFFSET(AmurSensors_HandCurrent, leftcurrent_)>(
          reinterpret_cast<char*>(&leftcurrent_),
          reinterpret_cast<char*>(&other->leftcurrent_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AmurSensors_HandCurrent::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AmurSensors_Misc::InitAsDefaultInstance() {
}
class AmurSensors_Misc::_Internal {
 public:
};

AmurSensors_Misc::AmurSensors_Misc(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:AMUR.AmurSensors.Misc)
}
AmurSensors_Misc::AmurSensors_Misc(const AmurSensors_Misc& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&gas_, &from.gas_,
    static_cast<size_t>(reinterpret_cast<char*>(&pressure_) -
    reinterpret_cast<char*>(&gas_)) + sizeof(pressure_));
  // @@protoc_insertion_point(copy_constructor:AMUR.AmurSensors.Misc)
}

void AmurSensors_Misc::SharedCtor() {
  ::memset(&gas_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&pressure_) -
      reinterpret_cast<char*>(&gas_)) + sizeof(pressure_));
}

AmurSensors_Misc::~AmurSensors_Misc() {
  // @@protoc_insertion_point(destructor:AMUR.AmurSensors.Misc)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void AmurSensors_Misc::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void AmurSensors_Misc::ArenaDtor(void* object) {
  AmurSensors_Misc* _this = reinterpret_cast< AmurSensors_Misc* >(object);
  (void)_this;
}
void AmurSensors_Misc::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AmurSensors_Misc::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AmurSensors_Misc& AmurSensors_Misc::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AmurSensors_Misc_amur_2eproto.base);
  return *internal_default_instance();
}


void AmurSensors_Misc::Clear() {
// @@protoc_insertion_point(message_clear_start:AMUR.AmurSensors.Misc)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&gas_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&pressure_) -
      reinterpret_cast<char*>(&gas_)) + sizeof(pressure_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AmurSensors_Misc::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // int32 gas = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          gas_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 batteryVoltage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          batteryvoltage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 raspberryVoltage = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          raspberryvoltage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // float pressure = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          pressure_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AmurSensors_Misc::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AMUR.AmurSensors.Misc)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 gas = 1;
  if (this->gas() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_gas(), target);
  }

  // int32 batteryVoltage = 2;
  if (this->batteryvoltage() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_batteryvoltage(), target);
  }

  // int32 raspberryVoltage = 3;
  if (this->raspberryvoltage() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_raspberryvoltage(), target);
  }

  // float pressure = 4;
  if (!(this->pressure() <= 0 && this->pressure() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_pressure(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AMUR.AmurSensors.Misc)
  return target;
}

size_t AmurSensors_Misc::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AMUR.AmurSensors.Misc)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 gas = 1;
  if (this->gas() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_gas());
  }

  // int32 batteryVoltage = 2;
  if (this->batteryvoltage() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_batteryvoltage());
  }

  // int32 raspberryVoltage = 3;
  if (this->raspberryvoltage() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_raspberryvoltage());
  }

  // float pressure = 4;
  if (!(this->pressure() <= 0 && this->pressure() >= 0)) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AmurSensors_Misc::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:AMUR.AmurSensors.Misc)
  GOOGLE_DCHECK_NE(&from, this);
  const AmurSensors_Misc* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AmurSensors_Misc>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:AMUR.AmurSensors.Misc)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:AMUR.AmurSensors.Misc)
    MergeFrom(*source);
  }
}

void AmurSensors_Misc::MergeFrom(const AmurSensors_Misc& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AMUR.AmurSensors.Misc)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.gas() != 0) {
    _internal_set_gas(from._internal_gas());
  }
  if (from.batteryvoltage() != 0) {
    _internal_set_batteryvoltage(from._internal_batteryvoltage());
  }
  if (from.raspberryvoltage() != 0) {
    _internal_set_raspberryvoltage(from._internal_raspberryvoltage());
  }
  if (!(from.pressure() <= 0 && from.pressure() >= 0)) {
    _internal_set_pressure(from._internal_pressure());
  }
}

void AmurSensors_Misc::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:AMUR.AmurSensors.Misc)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AmurSensors_Misc::CopyFrom(const AmurSensors_Misc& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AMUR.AmurSensors.Misc)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AmurSensors_Misc::IsInitialized() const {
  return true;
}

void AmurSensors_Misc::InternalSwap(AmurSensors_Misc* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AmurSensors_Misc, pressure_)
      + sizeof(AmurSensors_Misc::pressure_)
      - PROTOBUF_FIELD_OFFSET(AmurSensors_Misc, gas_)>(
          reinterpret_cast<char*>(&gas_),
          reinterpret_cast<char*>(&other->gas_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AmurSensors_Misc::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AmurSensors::InitAsDefaultInstance() {
  ::AMUR::_AmurSensors_default_instance_._instance.get_mutable()->accelerometer_ = const_cast< ::AMUR::AmurSensors_Accelerometer*>(
      ::AMUR::AmurSensors_Accelerometer::internal_default_instance());
  ::AMUR::_AmurSensors_default_instance_._instance.get_mutable()->gyroscope_ = const_cast< ::AMUR::AmurSensors_Gyroscope*>(
      ::AMUR::AmurSensors_Gyroscope::internal_default_instance());
  ::AMUR::_AmurSensors_default_instance_._instance.get_mutable()->magnitometer_ = const_cast< ::AMUR::AmurSensors_Magnitometer*>(
      ::AMUR::AmurSensors_Magnitometer::internal_default_instance());
  ::AMUR::_AmurSensors_default_instance_._instance.get_mutable()->wheelencoders_ = const_cast< ::AMUR::AmurSensors_WheelEncoders*>(
      ::AMUR::AmurSensors_WheelEncoders::internal_default_instance());
  ::AMUR::_AmurSensors_default_instance_._instance.get_mutable()->handencoders_ = const_cast< ::AMUR::AmurSensors_HandEncoders*>(
      ::AMUR::AmurSensors_HandEncoders::internal_default_instance());
  ::AMUR::_AmurSensors_default_instance_._instance.get_mutable()->temperature_ = const_cast< ::AMUR::AmurSensors_Temperature*>(
      ::AMUR::AmurSensors_Temperature::internal_default_instance());
  ::AMUR::_AmurSensors_default_instance_._instance.get_mutable()->misc_ = const_cast< ::AMUR::AmurSensors_Misc*>(
      ::AMUR::AmurSensors_Misc::internal_default_instance());
}
class AmurSensors::_Internal {
 public:
  static const ::AMUR::AmurSensors_Accelerometer& accelerometer(const AmurSensors* msg);
  static const ::AMUR::AmurSensors_Gyroscope& gyroscope(const AmurSensors* msg);
  static const ::AMUR::AmurSensors_Magnitometer& magnitometer(const AmurSensors* msg);
  static const ::AMUR::AmurSensors_WheelEncoders& wheelencoders(const AmurSensors* msg);
  static const ::AMUR::AmurSensors_HandEncoders& handencoders(const AmurSensors* msg);
  static const ::AMUR::AmurSensors_Temperature& temperature(const AmurSensors* msg);
  static const ::AMUR::AmurSensors_Misc& misc(const AmurSensors* msg);
};

const ::AMUR::AmurSensors_Accelerometer&
AmurSensors::_Internal::accelerometer(const AmurSensors* msg) {
  return *msg->accelerometer_;
}
const ::AMUR::AmurSensors_Gyroscope&
AmurSensors::_Internal::gyroscope(const AmurSensors* msg) {
  return *msg->gyroscope_;
}
const ::AMUR::AmurSensors_Magnitometer&
AmurSensors::_Internal::magnitometer(const AmurSensors* msg) {
  return *msg->magnitometer_;
}
const ::AMUR::AmurSensors_WheelEncoders&
AmurSensors::_Internal::wheelencoders(const AmurSensors* msg) {
  return *msg->wheelencoders_;
}
const ::AMUR::AmurSensors_HandEncoders&
AmurSensors::_Internal::handencoders(const AmurSensors* msg) {
  return *msg->handencoders_;
}
const ::AMUR::AmurSensors_Temperature&
AmurSensors::_Internal::temperature(const AmurSensors* msg) {
  return *msg->temperature_;
}
const ::AMUR::AmurSensors_Misc&
AmurSensors::_Internal::misc(const AmurSensors* msg) {
  return *msg->misc_;
}
AmurSensors::AmurSensors(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:AMUR.AmurSensors)
}
AmurSensors::AmurSensors(const AmurSensors& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_accelerometer()) {
    accelerometer_ = new ::AMUR::AmurSensors_Accelerometer(*from.accelerometer_);
  } else {
    accelerometer_ = nullptr;
  }
  if (from._internal_has_gyroscope()) {
    gyroscope_ = new ::AMUR::AmurSensors_Gyroscope(*from.gyroscope_);
  } else {
    gyroscope_ = nullptr;
  }
  if (from._internal_has_magnitometer()) {
    magnitometer_ = new ::AMUR::AmurSensors_Magnitometer(*from.magnitometer_);
  } else {
    magnitometer_ = nullptr;
  }
  if (from._internal_has_wheelencoders()) {
    wheelencoders_ = new ::AMUR::AmurSensors_WheelEncoders(*from.wheelencoders_);
  } else {
    wheelencoders_ = nullptr;
  }
  if (from._internal_has_handencoders()) {
    handencoders_ = new ::AMUR::AmurSensors_HandEncoders(*from.handencoders_);
  } else {
    handencoders_ = nullptr;
  }
  if (from._internal_has_temperature()) {
    temperature_ = new ::AMUR::AmurSensors_Temperature(*from.temperature_);
  } else {
    temperature_ = nullptr;
  }
  if (from._internal_has_misc()) {
    misc_ = new ::AMUR::AmurSensors_Misc(*from.misc_);
  } else {
    misc_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:AMUR.AmurSensors)
}

void AmurSensors::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AmurSensors_amur_2eproto.base);
  ::memset(&accelerometer_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&misc_) -
      reinterpret_cast<char*>(&accelerometer_)) + sizeof(misc_));
}

AmurSensors::~AmurSensors() {
  // @@protoc_insertion_point(destructor:AMUR.AmurSensors)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void AmurSensors::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete accelerometer_;
  if (this != internal_default_instance()) delete gyroscope_;
  if (this != internal_default_instance()) delete magnitometer_;
  if (this != internal_default_instance()) delete wheelencoders_;
  if (this != internal_default_instance()) delete handencoders_;
  if (this != internal_default_instance()) delete temperature_;
  if (this != internal_default_instance()) delete misc_;
}

void AmurSensors::ArenaDtor(void* object) {
  AmurSensors* _this = reinterpret_cast< AmurSensors* >(object);
  (void)_this;
}
void AmurSensors::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AmurSensors::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AmurSensors& AmurSensors::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AmurSensors_amur_2eproto.base);
  return *internal_default_instance();
}


void AmurSensors::Clear() {
// @@protoc_insertion_point(message_clear_start:AMUR.AmurSensors)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArena() == nullptr && accelerometer_ != nullptr) {
    delete accelerometer_;
  }
  accelerometer_ = nullptr;
  if (GetArena() == nullptr && gyroscope_ != nullptr) {
    delete gyroscope_;
  }
  gyroscope_ = nullptr;
  if (GetArena() == nullptr && magnitometer_ != nullptr) {
    delete magnitometer_;
  }
  magnitometer_ = nullptr;
  if (GetArena() == nullptr && wheelencoders_ != nullptr) {
    delete wheelencoders_;
  }
  wheelencoders_ = nullptr;
  if (GetArena() == nullptr && handencoders_ != nullptr) {
    delete handencoders_;
  }
  handencoders_ = nullptr;
  if (GetArena() == nullptr && temperature_ != nullptr) {
    delete temperature_;
  }
  temperature_ = nullptr;
  if (GetArena() == nullptr && misc_ != nullptr) {
    delete misc_;
  }
  misc_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AmurSensors::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .AMUR.AmurSensors.Accelerometer accelerometer = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_accelerometer(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .AMUR.AmurSensors.Gyroscope gyroscope = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_gyroscope(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .AMUR.AmurSensors.Magnitometer magnitometer = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_magnitometer(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .AMUR.AmurSensors.WheelEncoders wheelEncoders = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_wheelencoders(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .AMUR.AmurSensors.HandEncoders handEncoders = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_handencoders(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .AMUR.AmurSensors.Temperature temperature = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_temperature(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .AMUR.AmurSensors.Misc misc = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_misc(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AmurSensors::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AMUR.AmurSensors)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .AMUR.AmurSensors.Accelerometer accelerometer = 1;
  if (this->has_accelerometer()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::accelerometer(this), target, stream);
  }

  // .AMUR.AmurSensors.Gyroscope gyroscope = 2;
  if (this->has_gyroscope()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::gyroscope(this), target, stream);
  }

  // .AMUR.AmurSensors.Magnitometer magnitometer = 3;
  if (this->has_magnitometer()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::magnitometer(this), target, stream);
  }

  // .AMUR.AmurSensors.WheelEncoders wheelEncoders = 4;
  if (this->has_wheelencoders()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::wheelencoders(this), target, stream);
  }

  // .AMUR.AmurSensors.HandEncoders handEncoders = 5;
  if (this->has_handencoders()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::handencoders(this), target, stream);
  }

  // .AMUR.AmurSensors.Temperature temperature = 6;
  if (this->has_temperature()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::temperature(this), target, stream);
  }

  // .AMUR.AmurSensors.Misc misc = 7;
  if (this->has_misc()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::misc(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AMUR.AmurSensors)
  return target;
}

size_t AmurSensors::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AMUR.AmurSensors)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .AMUR.AmurSensors.Accelerometer accelerometer = 1;
  if (this->has_accelerometer()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *accelerometer_);
  }

  // .AMUR.AmurSensors.Gyroscope gyroscope = 2;
  if (this->has_gyroscope()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *gyroscope_);
  }

  // .AMUR.AmurSensors.Magnitometer magnitometer = 3;
  if (this->has_magnitometer()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *magnitometer_);
  }

  // .AMUR.AmurSensors.WheelEncoders wheelEncoders = 4;
  if (this->has_wheelencoders()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *wheelencoders_);
  }

  // .AMUR.AmurSensors.HandEncoders handEncoders = 5;
  if (this->has_handencoders()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *handencoders_);
  }

  // .AMUR.AmurSensors.Temperature temperature = 6;
  if (this->has_temperature()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *temperature_);
  }

  // .AMUR.AmurSensors.Misc misc = 7;
  if (this->has_misc()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *misc_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AmurSensors::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:AMUR.AmurSensors)
  GOOGLE_DCHECK_NE(&from, this);
  const AmurSensors* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AmurSensors>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:AMUR.AmurSensors)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:AMUR.AmurSensors)
    MergeFrom(*source);
  }
}

void AmurSensors::MergeFrom(const AmurSensors& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AMUR.AmurSensors)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_accelerometer()) {
    _internal_mutable_accelerometer()->::AMUR::AmurSensors_Accelerometer::MergeFrom(from._internal_accelerometer());
  }
  if (from.has_gyroscope()) {
    _internal_mutable_gyroscope()->::AMUR::AmurSensors_Gyroscope::MergeFrom(from._internal_gyroscope());
  }
  if (from.has_magnitometer()) {
    _internal_mutable_magnitometer()->::AMUR::AmurSensors_Magnitometer::MergeFrom(from._internal_magnitometer());
  }
  if (from.has_wheelencoders()) {
    _internal_mutable_wheelencoders()->::AMUR::AmurSensors_WheelEncoders::MergeFrom(from._internal_wheelencoders());
  }
  if (from.has_handencoders()) {
    _internal_mutable_handencoders()->::AMUR::AmurSensors_HandEncoders::MergeFrom(from._internal_handencoders());
  }
  if (from.has_temperature()) {
    _internal_mutable_temperature()->::AMUR::AmurSensors_Temperature::MergeFrom(from._internal_temperature());
  }
  if (from.has_misc()) {
    _internal_mutable_misc()->::AMUR::AmurSensors_Misc::MergeFrom(from._internal_misc());
  }
}

void AmurSensors::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:AMUR.AmurSensors)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AmurSensors::CopyFrom(const AmurSensors& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AMUR.AmurSensors)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AmurSensors::IsInitialized() const {
  return true;
}

void AmurSensors::InternalSwap(AmurSensors* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AmurSensors, misc_)
      + sizeof(AmurSensors::misc_)
      - PROTOBUF_FIELD_OFFSET(AmurSensors, accelerometer_)>(
          reinterpret_cast<char*>(&accelerometer_),
          reinterpret_cast<char*>(&other->accelerometer_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AmurSensors::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace AMUR
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::AMUR::AmurControls_CameraServos* Arena::CreateMaybeMessage< ::AMUR::AmurControls_CameraServos >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AMUR::AmurControls_CameraServos >(arena);
}
template<> PROTOBUF_NOINLINE ::AMUR::AmurControls_WheelMotors* Arena::CreateMaybeMessage< ::AMUR::AmurControls_WheelMotors >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AMUR::AmurControls_WheelMotors >(arena);
}
template<> PROTOBUF_NOINLINE ::AMUR::AmurControls_HandMotors* Arena::CreateMaybeMessage< ::AMUR::AmurControls_HandMotors >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AMUR::AmurControls_HandMotors >(arena);
}
template<> PROTOBUF_NOINLINE ::AMUR::AmurControls_Light* Arena::CreateMaybeMessage< ::AMUR::AmurControls_Light >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AMUR::AmurControls_Light >(arena);
}
template<> PROTOBUF_NOINLINE ::AMUR::AmurControls_System* Arena::CreateMaybeMessage< ::AMUR::AmurControls_System >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AMUR::AmurControls_System >(arena);
}
template<> PROTOBUF_NOINLINE ::AMUR::AmurControls* Arena::CreateMaybeMessage< ::AMUR::AmurControls >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AMUR::AmurControls >(arena);
}
template<> PROTOBUF_NOINLINE ::AMUR::AmurSensors_Accelerometer* Arena::CreateMaybeMessage< ::AMUR::AmurSensors_Accelerometer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AMUR::AmurSensors_Accelerometer >(arena);
}
template<> PROTOBUF_NOINLINE ::AMUR::AmurSensors_Gyroscope* Arena::CreateMaybeMessage< ::AMUR::AmurSensors_Gyroscope >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AMUR::AmurSensors_Gyroscope >(arena);
}
template<> PROTOBUF_NOINLINE ::AMUR::AmurSensors_Magnitometer* Arena::CreateMaybeMessage< ::AMUR::AmurSensors_Magnitometer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AMUR::AmurSensors_Magnitometer >(arena);
}
template<> PROTOBUF_NOINLINE ::AMUR::AmurSensors_WheelEncoders* Arena::CreateMaybeMessage< ::AMUR::AmurSensors_WheelEncoders >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AMUR::AmurSensors_WheelEncoders >(arena);
}
template<> PROTOBUF_NOINLINE ::AMUR::AmurSensors_HandEncoders* Arena::CreateMaybeMessage< ::AMUR::AmurSensors_HandEncoders >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AMUR::AmurSensors_HandEncoders >(arena);
}
template<> PROTOBUF_NOINLINE ::AMUR::AmurSensors_Temperature* Arena::CreateMaybeMessage< ::AMUR::AmurSensors_Temperature >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AMUR::AmurSensors_Temperature >(arena);
}
template<> PROTOBUF_NOINLINE ::AMUR::AmurSensors_WheelCurrent* Arena::CreateMaybeMessage< ::AMUR::AmurSensors_WheelCurrent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AMUR::AmurSensors_WheelCurrent >(arena);
}
template<> PROTOBUF_NOINLINE ::AMUR::AmurSensors_HandCurrent* Arena::CreateMaybeMessage< ::AMUR::AmurSensors_HandCurrent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AMUR::AmurSensors_HandCurrent >(arena);
}
template<> PROTOBUF_NOINLINE ::AMUR::AmurSensors_Misc* Arena::CreateMaybeMessage< ::AMUR::AmurSensors_Misc >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AMUR::AmurSensors_Misc >(arena);
}
template<> PROTOBUF_NOINLINE ::AMUR::AmurSensors* Arena::CreateMaybeMessage< ::AMUR::AmurSensors >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AMUR::AmurSensors >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
